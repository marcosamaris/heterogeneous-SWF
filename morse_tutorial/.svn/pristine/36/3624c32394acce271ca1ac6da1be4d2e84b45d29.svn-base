#+TITLE: Mini Chameleon Tutorial
#+AUTHOR: HiePACS/STORM Inria teams, Bordeaux

* Introduction
  This is a simple mini tutorial for installing Chameleon with all the
  necessary software stack using *spack* and for running tiled cholesky
  factorization. We present how to run this task-based application
  using *StarPU*, but also how to simulate the execution (using
  *StarPU-SimGrid*, which allows for accurate performance predictions
  for the different scenarios.
** Emacs and Org-mode
   This tutorial is written in [[http://orgmode.org/][Org-mode]] and it is based on its
   literate programming feature [[http://orgmode.org/worg/org-contrib/babel/][Org-babel]]. Although Org-mode files can
   be read in any text editors, we strongly encourage to use Emacs, as
   at this point only this editor allows for fully benefiting from
   Org-babel feature.

   In order to run everything smoothly, you will need recent Emacs
   (>24.3) and a recent Org-mode (>8.0). If you have trouble
   installing this software, consult the following web [[http://mescal.imag.fr/membres/arnaud.legrand/misc/init.php][page]]
   (or this [[http://mescal.imag.fr/membres/arnaud.legrand/blog/2014/05/15/emacs_and_orgmode_on_macosx.php][one]] if you are a Mac user).

   Once everything is installed, execute the following code by
   selecting it with cursor and applying the shortcut "Ctrl-c Ctrl-c"
   to test that everything works properly. This small code will
   execute shell command echo with the specified text.
 #+BEGIN_SRC sh :exports both
   echo "foo"
 #+END_SRC

 #+RESULTS:
 : foo

   Now execute this code to set the environment in order to be able to
   execute shell and not have to confirm every command.
 #+BEGIN_SRC emacs-lisp :results none :exports code
 (setq org-confirm-babel-evaluate nil)
 (setq org-export-babel-evaluate nil)
 (org-babel-do-load-languages 'org-babel-load-languages
      '(
       (sh . t)
       (python . t)
       (R . t)
       (org . t)
       ))
 #+END_SRC

* Installation with spack
   Here we provide a short example, more info about spack can be found
   [[http://morse.gforge.inria.fr/tuto_spack-morse/tuto_spack.html#sec-1][here]].

   Clone spack git on your local computer.
   #+BEGIN_SRC sh :session local :results none :exports code
   git clone https://github.com/fpruvost/spack.git
   cd spack
   git checkout morse
   #+END_SRC

   Configure spack correctly, adding the binary to your machine path.
   #+BEGIN_SRC sh :session local :results none :exports code
   export SPACK_ROOT=$PWD
   export PATH=$SPACK_ROOT/bin:$PATH
   export SPACK_VER=`spack --version 2>&1`
   echo "Spack version is $SPACK_VER"
   #+END_SRC

   Check the stack that you plan to install.
   #+BEGIN_SRC sh :session local :results value :exports code
   spack spec chameleon@trunk~quark+examples ^netlib-blas ^starpu@svn-trunk
   #+END_SRC

   The result is long and not in such a nice format, but you can
   always fold it by clicking TAB on the "RESULTS". You can open Emacs
   buffer called /local/ next to this file and see the output of all the
   executed commands there as well.

   If everything looks fine, install the software stack using spack.
   #+BEGIN_SRC sh :session local :results none :exports code
   spack install -v chameleon@trunk~quark+examples ^netlib-blas ^starpu@svn-trunk
   #+END_SRC

   Now also install the similar software stack only for the simulation.
   #+BEGIN_SRC sh :session local :results none :exports code
   spack install -v chameleon@trunk~quark+simu+examples ^netlib-blas  ^starpu@svn-trunk+simu ^simgrid@git-starpumpi
   #+END_SRC

* Run a single real experiments
   We will just configure that StarPU saves its perfmodels in this
   folder. Also for the size of the tile we will choose 320, since it
   works good for the CPUs. If you have GPUs installed on you machine,
   it is better to change this value for the 960.
   #+BEGIN_SRC sh :session local :results none :exports code
   export STARPU_HOME=$PWD
   export TILE_SIZE=320
   #+END_SRC

   Execute the real cholesky factorization of Chameleon. We make sure
   that StarPU calibration is stored in the StarPU home folder. We
   also allow a huge variation of the kernel duration (increasing
   maximal error to 1000%).
   #+BEGIN_SRC sh :session local :results output :exports both
   STARPU_NCPU=4 STARPU_CALIBRATE=1 STARPU_HISTORY_MAX_ERROR=1000 `spack location -i chameleon@trunk~quark+examples~simu`/lib/chameleon/timing/time_dpotrf_tile --n_range=$(($TILE_SIZE*10)):$(($TILE_SIZE*10)):$(($TILE_SIZE*10)) --nb=$TILE_SIZE
   #+END_SRC

   Together with the results, this execution also produced a platform
   description of your machine.
   #+BEGIN_SRC sh :session local :results output :exports both
   ls .starpu/sampling/bus/
   #+END_SRC

   And the performance models of the kernels used in cholesky.
   #+BEGIN_SRC sh :session local :results output :exports both
   ls .starpu/sampling/codelets/44/
   #+END_SRC

* StarPU-SimGrid in a nutshell
 #+ATTR_HTML: :align center
 [[file:figures/starpusg_big_slide.png]]

 More information on project [[http://starpu-simgrid.gforge.inria.fr/][website]].
* Run many simulations
  Now run the simulation using the perfmodels and platform description
  generated when doing a real execution.
   #+BEGIN_SRC sh :session local :results output :exports both
   STARPU_NCPU=4 `spack location -i chameleon@trunk~quark+simu+examples`/lib/chameleon/timing/time_dpotrf_tile --n_range=$(($TILE_SIZE*10)):$(($TILE_SIZE*10)):$(($TILE_SIZE*10)) --nb=$TILE_SIZE --nowarmup
   #+END_SRC

   Lets now execute the same program but using a larger matrix. Note
   that we can now do a simulation directly, as a platform description
   and performance models for the kernels used in cholesky have
   already been calibrated before.
   #+BEGIN_SRC sh :session local :results output :exports both
   STARPU_NCPU=4 `spack location -i chameleon@trunk~quark+simu+examples`/lib/chameleon/timing/time_dpotrf_tile --n_range=$(($TILE_SIZE*100)):$(($TILE_SIZE*100)):$(($TILE_SIZE*100)) --nb=$TILE_SIZE --nowarmup
   #+END_SRC

   One can observe that the makespan predicted by the simulation is
   much larger than the actual execution time of the simulation. This
   is due to the fact that when simulating no actual computation of
   the kernels is performed for real, only timings with their
   predicted durations are inserted.

   We can also try to change a StarPU scheduler to see if this
   improves the performance (important especially when using
   GPUs). Note that we are still relying on the same platform
   description and kernel performance models and that the new
   calibration is not needed.
   #+BEGIN_SRC sh :session local :results output :exports both
   STARPU_NCPU=4 STARPU_SCHED=dmdas `spack location -i chameleon@trunk~quark+simu+examples`/lib/chameleon/timing/time_dpotrf_tile --n_range=$(($TILE_SIZE*100)):$(($TILE_SIZE*100)):$(($TILE_SIZE*100)) --nb=$TILE_SIZE --nowarmup
   #+END_SRC


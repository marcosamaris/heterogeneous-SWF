<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Copyright (C) 2014 Inria

Copyright (C) 2014 The University of Tennessee

Copyright (C) 2014 King Abdullah University of Science and Technology

Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:
Redistributions of source code must retain the above copyright notice, this 
list 
of conditions and the following disclaimer.

Redistributions in binary form must reproduce the above copyright notice, this  
list of conditions and the following disclaimer listed in this license in the 
documentation and/or other materials provided with the distribution.

Neither the name of the copyright holders nor the names of its contributors may 
be used to endorse or promote products derived from this software without 
specific prior written permission.

This software is provided by the copyright holders and contributors "as is" and 
any express or implied warranties, including, but not limited to, the implied 
warranties of merchantability and fitness for a particular purpose are 
disclaimed. 
In no event shall the copyright owner or contributors be liable for any direct, 
indirect, incidental, special, exemplary, or consequential damages (including, 
but not limited to, procurement of substitute goods or services; loss of use, 
data, or profits; or business interruption) however caused and on any theory of 
liability, whether in contract, strict liability, or tort (including negligence 
or otherwise) arising in any way out of the use of this software, even if 
advised of the possibility of such damage. -->
<!-- Created by GNU Texinfo 5.2, http://www.gnu.org/software/texinfo/ -->
<head>
<title>CHAMELEON User&rsquo;s Guide</title>

<meta name="description" content="CHAMELEON User&rsquo;s Guide">
<meta name="keywords" content="CHAMELEON User&rsquo;s Guide">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link href="#Top" rel="start" title="Top">
<link href="#SEC_Contents" rel="contents" title="Table of Contents">
<link href="dir.html#Top" rel="up" title="(dir)">
<style type="text/css">
<!--
a.summary-letter {text-decoration: none}
blockquote.smallquotation {font-size: smaller}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
div.indentedblock {margin-left: 3.2em}
div.lisp {margin-left: 3.2em}
div.smalldisplay {margin-left: 3.2em}
div.smallexample {margin-left: 3.2em}
div.smallindentedblock {margin-left: 3.2em; font-size: smaller}
div.smalllisp {margin-left: 3.2em}
kbd {font-style:oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
pre.smalldisplay {font-family: inherit; font-size: smaller}
pre.smallexample {font-size: smaller}
pre.smallformat {font-family: inherit; font-size: smaller}
pre.smalllisp {font-size: smaller}
span.nocodebreak {white-space:nowrap}
span.nolinebreak {white-space:nowrap}
span.roman {font-family:serif; font-weight:normal}
span.sansserif {font-family:sans-serif; font-weight:normal}
ul.no-bullet {list-style: none}
body {
  padding: 2em 1em 2em 70px;
  margin: 0;
  font-family: sans-serif;
  color: black;
  background: white;
  background-position: top left;
  background-attachment: fixed;
  background-repeat: no-repeat;
}
:link { color: #00C; background: transparent }
:visited { color: #609; background: transparent }
a:active { color: #C00; background: transparent }

a:link img, a:visited img { border-style: none }

a img { color: white; }
@media all {
  a img { color: inherit; }
}

th, td {
  font-family: sans-serif;
}

h1, h2, h3, h4, h5, h6 { text-align: left }
h1, h2, h3 { color: #005A9C; background: white }
h1 { font: 170% sans-serif }
h2 { font: 140% sans-serif }
h3 { font: 120% sans-serif }
h4 { font: bold 100% sans-serif }
h5 { font: italic 100% sans-serif }
h6 { font: small-caps 100% sans-serif }

.hide { display: none }

div.head { margin-bottom: 1em }
div.head h1 { margin-top: 2em; clear: both }
div.head table { margin-left: 2em; margin-top: 2em }

p.copyright { font-size: small }
p.copyright small { font-size: small }

@media screen {
a[href]:hover { background: #ffa }
}

pre { margin-left: 2em }

dt, dd { margin-top: 0; margin-bottom: 0 }
dt { font-weight: bold }

pre, code { font-family: monospace }

ul.toc, ol.toc {
  list-style: disc;
  list-style: none;
}

@media aural {  
  h1, h2, h3 { stress: 20; richness: 90 }
  .hide { speak: none }
  p.copyright { volume: x-soft; speech-rate: x-fast }
  dt { pause-before: 20% }
  pre { speak-punctuation: code } 
}

/*
body {
  background-image: url();
}
*/

-->
</style>


</head>

<body lang="en" bgcolor="#FFFFFF" text="#000000" link="#0000FF" vlink="#800080" alink="#FF0000">
<h1 class="settitle" align="center">CHAMELEON User&rsquo;s Guide</h1>









<a name="SEC_Contents"></a>
<h2 class="contents-heading">Table of Contents</h2>

<div class="contents">

<ul class="no-bullet">
  <li><a name="toc-Introduction-to-CHAMELEON" href="#Introduction">1 Introduction to CHAMELEON</a>
  <ul class="no-bullet">
    <li><a name="toc-MORSE-project-1" href="#MORSE-project">1.1 MORSE project</a>
    <ul class="no-bullet">
      <li><a name="toc-MORSE-Objectives-1" href="#MORSE-Objectives">1.1.1 MORSE Objectives</a></li>
      <li><a name="toc-Research-fields-1" href="#Research-fields">1.1.2 Research fields</a>
      <ul class="no-bullet">
        <li><a name="toc-Fine-interaction-between-linear-algebra-and-runtime-systems-1" href="#Fine-interaction-between-linear-algebra-and-runtime-systems">1.1.2.1 Fine interaction between linear algebra and runtime systems</a></li>
        <li><a name="toc-Runtime-systems-1" href="#Runtime-systems">1.1.2.2 Runtime systems</a></li>
        <li><a name="toc-Linear-algebra-1" href="#Linear-algebra">1.1.2.3 Linear algebra</a></li>
      </ul></li>
      <li><a name="toc-Research-papers-1" href="#Research-papers">1.1.3 Research papers</a></li>
    </ul></li>
    <li><a name="toc-CHAMELEON-1" href="#CHAMELEON">1.2 CHAMELEON</a>
    <ul class="no-bullet">
      <li><a name="toc-CHAMELEON-software-1" href="#CHAMELEON-software">1.2.1 CHAMELEON software</a></li>
      <li><a name="toc-PLASMA_0027s-design-principles-1" href="#PLASMA_0027s-design-principles">1.2.2 PLASMA&rsquo;s design principles</a>
      <ul class="no-bullet">
        <li><a name="toc-Tile-Algorithms-1" href="#Tile-Algorithms">1.2.2.1 Tile Algorithms</a></li>
        <li><a name="toc-Tile-Data-Layout-1" href="#Tile-Data-Layout">1.2.2.2 Tile Data Layout</a></li>
        <li><a name="toc-Dynamic-Task-Scheduling-1" href="#Dynamic-Task-Scheduling">1.2.2.3 Dynamic Task Scheduling</a></li>
      </ul></li>
    </ul></li>
  </ul></li>
  <li><a name="toc-Installing-CHAMELEON-1" href="#Installing-CHAMELEON">2 Installing CHAMELEON</a>
  <ul class="no-bullet">
    <li><a name="toc-Downloading-CHAMELEON-1" href="#Downloading-CHAMELEON">2.1 Downloading CHAMELEON</a>
    <ul class="no-bullet">
      <li><a name="toc-Getting-Sources-1" href="#Getting-Sources">2.1.1 Getting Sources</a></li>
      <li><a name="toc-Required-dependencies-1" href="#Required-dependencies">2.1.2 Required dependencies</a>
      <ul class="no-bullet">
        <li><a name="toc-a-BLAS-implementation-1" href="#a-BLAS-implementation">2.1.2.1 a BLAS implementation</a></li>
        <li><a name="toc-CBLAS-1" href="#CBLAS">2.1.2.2 CBLAS</a></li>
        <li><a name="toc-a-LAPACK-implementation-1" href="#a-LAPACK-implementation">2.1.2.3 a LAPACK implementation</a></li>
        <li><a name="toc-LAPACKE-1" href="#LAPACKE">2.1.2.4 LAPACKE</a></li>
        <li><a name="toc-libtmg-1" href="#libtmg">2.1.2.5 libtmg</a></li>
        <li><a name="toc-QUARK-1" href="#QUARK">2.1.2.6 QUARK</a></li>
        <li><a name="toc-StarPU-1" href="#StarPU">2.1.2.7 StarPU</a></li>
        <li><a name="toc-hwloc-1" href="#hwloc">2.1.2.8 hwloc</a></li>
        <li><a name="toc-pthread-1" href="#pthread">2.1.2.9 pthread</a></li>
      </ul></li>
      <li><a name="toc-Optional-dependencies-1" href="#Optional-dependencies">2.1.3 Optional dependencies</a>
      <ul class="no-bullet">
        <li><a name="toc-OpenMPI-1" href="#OpenMPI">2.1.3.1 OpenMPI</a></li>
        <li><a name="toc-Nvidia-CUDA-Toolkit-1" href="#Nvidia-CUDA-Toolkit">2.1.3.2 Nvidia CUDA Toolkit</a></li>
        <li><a name="toc-MAGMA-1" href="#MAGMA">2.1.3.3 MAGMA</a></li>
        <li><a name="toc-FxT-1" href="#FxT">2.1.3.4 FxT</a></li>
      </ul></li>
    </ul></li>
    <li><a name="toc-Build-process-of-CHAMELEON-1" href="#Build-process-of-CHAMELEON">2.2 Build process of CHAMELEON</a>
    <ul class="no-bullet">
      <li><a name="toc-Setting-up-a-build-directory-1" href="#Setting-up-a-build-directory">2.2.1 Setting up a build directory</a></li>
      <li><a name="toc-Configuring-the-project-with-best-efforts-1" href="#Configuring-the-project-with-best-efforts">2.2.2 Configuring the project with best efforts</a></li>
      <li><a name="toc-Building-1" href="#Building">2.2.3 Building</a></li>
      <li><a name="toc-Tests-1" href="#Tests">2.2.4 Tests</a></li>
      <li><a name="toc-Installing-1" href="#Installing">2.2.5 Installing</a></li>
    </ul></li>
  </ul></li>
  <li><a name="toc-Configuring-CHAMELEON-1" href="#Configuring-CHAMELEON">3 Configuring CHAMELEON</a>
  <ul class="no-bullet">
    <li><a name="toc-Compilation-configuration-1" href="#Compilation-configuration">3.1 Compilation configuration</a>
    <ul class="no-bullet">
      <li><a name="toc-General-CMake-options-1" href="#General-CMake-options">3.1.1 General CMake options</a></li>
      <li><a name="toc-CHAMELEON-options-1" href="#CHAMELEON-options">3.1.2 CHAMELEON options</a></li>
    </ul></li>
    <li><a name="toc-Dependencies-detection-1" href="#Dependencies-detection">3.2 Dependencies detection</a></li>
    <li><a name="toc-Use-FxT-profiling-through-StarPU-1" href="#Use-FxT-profiling-through-StarPU">3.3 Use FxT profiling through StarPU</a></li>
    <li><a name="toc-Use-simulation-mode-with-StarPU_002dSimGrid-1" href="#Use-simulation-mode-with-StarPU_002dSimGrid">3.4 Use simulation mode with StarPU-SimGrid</a></li>
  </ul></li>
  <li><a name="toc-Using-CHAMELEON-1" href="#Using-CHAMELEON">4 Using CHAMELEON</a>
  <ul class="no-bullet">
    <li><a name="toc-Using-CHAMELEON-executables-1" href="#Using-CHAMELEON-executables">4.1 Using CHAMELEON executables</a></li>
    <li><a name="toc-Linking-an-external-application-with-CHAMELEON-libraries-1" href="#Linking-an-external-application-with-CHAMELEON-libraries">4.2 Linking an external application with CHAMELEON libraries</a>
    <ul class="no-bullet">
      <li><a name="toc-Static-linking-in-C-1" href="#Static-linking-in-C">4.2.1 Static linking in C</a></li>
      <li><a name="toc-Dynamic-linking-in-C-1" href="#Dynamic-linking-in-C">4.2.2 Dynamic linking in C</a></li>
      <li><a name="toc-Build-a-Fortran-program-with-CHAMELEON-1" href="#Build-a-Fortran-program-with-CHAMELEON">4.2.3 Build a Fortran program with CHAMELEON</a></li>
    </ul></li>
    <li><a name="toc-CHAMELEON-API-1" href="#CHAMELEON-API">4.3 CHAMELEON API</a>
    <ul class="no-bullet">
      <li><a name="toc-Tutorial-LAPACK-to-CHAMELEON-1" href="#Tutorial-LAPACK-to-CHAMELEON">4.3.1 Tutorial LAPACK to CHAMELEON</a>
      <ul class="no-bullet">
        <li><a name="toc-Step0-1" href="#Step0">4.3.1.1 Step0</a></li>
        <li><a name="toc-Step1-1" href="#Step1">4.3.1.2 Step1</a></li>
        <li><a name="toc-Step2-1" href="#Step2">4.3.1.3 Step2</a></li>
        <li><a name="toc-Step3-1" href="#Step3">4.3.1.4 Step3</a></li>
        <li><a name="toc-Step4-1" href="#Step4">4.3.1.5 Step4</a></li>
        <li><a name="toc-Step5-1" href="#Step5">4.3.1.6 Step5</a></li>
        <li><a name="toc-Step6-1" href="#Step6">4.3.1.7 Step6</a></li>
      </ul></li>
      <li><a name="toc-List-of-available-routines-1" href="#List-of-available-routines">4.3.2 List of available routines</a>
      <ul class="no-bullet">
        <li><a name="toc-Auxiliary-routines-1" href="#Auxiliary-routines">4.3.2.1 Auxiliary routines</a></li>
        <li><a name="toc-Descriptor-routines-1" href="#Descriptor-routines">4.3.2.2 Descriptor routines</a></li>
        <li><a name="toc-Options-routines-1" href="#Options-routines">4.3.2.3 Options routines</a></li>
        <li><a name="toc-Sequences-routines-1" href="#Sequences-routines">4.3.2.4 Sequences routines</a></li>
        <li><a name="toc-Linear-Algebra-routines-1" href="#Linear-Algebra-routines">4.3.2.5 Linear Algebra routines</a></li>
      </ul></li>
    </ul></li>
  </ul></li>
</ul>
</div>


<a name="Top"></a>
<div class="header">
<p>
Next: <a href="#Introduction" accesskey="n" rel="next">Introduction</a>, Up: <a href="dir.html#Top" accesskey="u" rel="up">(dir)</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Preface"></a>
<h1 class="top">Preface</h1>

<p>This manual documents the usage of CHAMELEON version 0.9.. 
It was last updated on 15 November 2014.
</p>
<p>Copyright &copy; 2014 Inria
</p>
<p>Copyright &copy; 2014 The University of Tennessee
</p>
<p>Copyright &copy; 2014 King Abdullah University of Science and Technology
</p>
<blockquote>
<p>Redistribution and use in source and binary forms, with or without 
modification, are permitted provided that the following conditions are met:
</p><ul>
<li> Redistributions of source code must retain the above copyright notice, this 
list 
of conditions and the following disclaimer.

</li><li> Redistributions in binary form must reproduce the above copyright notice, this  
list of conditions and the following disclaimer listed in this license in the 
documentation and/or other materials provided with the distribution.

</li><li> Neither the name of the copyright holders nor the names of its contributors may 
be used to endorse or promote products derived from this software without 
specific prior written permission.
</li></ul>

<p>This software is provided by the copyright holders and contributors &quot;as is&quot; and 
any express or implied warranties, including, but not limited to, the implied 
warranties of merchantability and fitness for a particular purpose are 
disclaimed. 
In no event shall the copyright owner or contributors be liable for any direct, 
indirect, incidental, special, exemplary, or consequential damages (including, 
but not limited to, procurement of substitute goods or services; loss of use, 
data, or profits; or business interruption) however caused and on any theory of 
liability, whether in contract, strict liability, or tort (including negligence 
or otherwise) arising in any way out of the use of this software, even if 
advised of the possibility of such damage.
</p></blockquote>


<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Introduction" accesskey="1">Introduction</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Getting started
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Installing-CHAMELEON" accesskey="2">Installing CHAMELEON</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">How to configure, build and install CHAMELEON
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Configuring-CHAMELEON" accesskey="3">Configuring CHAMELEON</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">How to configure CHAMELEON
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Using-CHAMELEON" accesskey="4">Using CHAMELEON</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">How to run CHAMELEON application
</td></tr>
</table>


<hr>
<a name="Introduction"></a>
<div class="header">
<p>
Next: <a href="#Installing-CHAMELEON" accesskey="n" rel="next">Installing CHAMELEON</a>, Previous: <a href="#Top" accesskey="p" rel="prev">Top</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Introduction-to-CHAMELEON"></a>
<h2 class="chapter">1 Introduction to CHAMELEON</h2>


<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#MORSE-project" accesskey="1">MORSE project</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Discussion about MORSE project motivation
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#CHAMELEON" accesskey="2">CHAMELEON</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Outline of this specific MORSE subproject
</td></tr>
</table>

<hr>
<a name="MORSE-project"></a>
<div class="header">
<p>
Next: <a href="#CHAMELEON" accesskey="n" rel="next">CHAMELEON</a>, Up: <a href="#Introduction" accesskey="u" rel="up">Introduction</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="MORSE-project-1"></a>
<h3 class="section">1.1 MORSE project</h3>

<div align="center"><img src="morse_header.png" alt="morse_header">
</div>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#MORSE-Objectives" accesskey="1">MORSE Objectives</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Research-fields" accesskey="2">Research fields</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Research-papers" accesskey="3">Research papers</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="MORSE-Objectives"></a>
<div class="header">
<p>
Next: <a href="#Research-fields" accesskey="n" rel="next">Research fields</a>, Up: <a href="#MORSE-project" accesskey="u" rel="up">MORSE project</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="MORSE-Objectives-1"></a>
<h4 class="subsection">1.1.1 MORSE Objectives</h4>

<p>When processor clock speeds flatlined in 2004, after more than fifteen years 
of exponential increases, the era of near automatic performance improvements 
that the HPC application community had previously enjoyed came to an abrupt 
end. 
To develop software that will perform well on petascale and exascale systems 
with thousands of nodes and millions of cores, the list of major challenges 
that must now be confronted is formidable: 
1) dramatic escalation in the costs of intrasystem communication between 
processors and/or levels of memory hierarchy; 
2) increased heterogeneity of the processing units (mixing CPUs, GPUs, etc. in 
varying and unexpected design combinations); 
3) high levels of parallelism and more complex constraints means that 
cooperating processes must be dynamically and unpredictably scheduled for 
asynchronous execution; 
4) software will not run at scale without much better resilience to faults and 
far more robustness; and 
5) new levels of self-adaptivity will be required to enable software to 
modulate process speed in order to satisfy limited energy budgets. 
The MORSE associate team will tackle the first three challenges in a 
orchestrating work between research groups respectively specialized in sparse 
linear algebra, dense linear algebra and runtime systems. 
The overall objective is to develop robust linear algebra libraries relying on 
innovative runtime systems that can fully benefit from the potential of those 
future large-scale complex machines. 
Challenges 4) and 5) will also be investigated by the different teams in the 
context of other partnerships, but they will not be the main focus of the 
associate team as they are much more prospective.
</p>
<hr>
<a name="Research-fields"></a>
<div class="header">
<p>
Next: <a href="#Research-papers" accesskey="n" rel="next">Research papers</a>, Previous: <a href="#MORSE-Objectives" accesskey="p" rel="prev">MORSE Objectives</a>, Up: <a href="#MORSE-project" accesskey="u" rel="up">MORSE project</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Research-fields-1"></a>
<h4 class="subsection">1.1.2 Research fields</h4>

<p>The overall goal of the MORSE associate team is to enable advanced numerical 
algorithms to be executed on a scalable unified runtime system for exploiting 
the full potential of future exascale machines.
We expect advances in three directions based first on strong and closed 
interactions between the runtime and numerical linear algebra communities. 
This initial activity will then naturally expand to more focused but still 
joint research in both fields.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Fine-interaction-between-linear-algebra-and-runtime-systems" accesskey="1">Fine interaction between linear algebra and runtime systems</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Runtime-systems" accesskey="2">Runtime systems</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Linear-algebra" accesskey="3">Linear algebra</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Fine-interaction-between-linear-algebra-and-runtime-systems"></a>
<div class="header">
<p>
Next: <a href="#Runtime-systems" accesskey="n" rel="next">Runtime systems</a>, Up: <a href="#Research-fields" accesskey="u" rel="up">Research fields</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Fine-interaction-between-linear-algebra-and-runtime-systems-1"></a>
<h4 class="subsubsection">1.1.2.1 Fine interaction between linear algebra and runtime systems</h4>

<p>On parallel machines, HPC applications need to take care of data movement and 
consistency, which can be either explicitly managed at the level of the 
application itself or delegated to a runtime system. 
We adopt the latter approach in order to better keep up with hardware trends 
whose complexity is growing exponentially. 
One major task in this project is to define a proper interface between HPC 
applications and runtime systems in order to maximize productivity and 
expressivity. 
As mentioned in the next section, a widely used approach consists in 
abstracting the application as a DAG that the runtime system is in charge of 
scheduling. 
Scheduling such a DAG over a set of heterogeneous processing units introduces a 
lot of new challenges, such as predicting accurately the execution time of each 
type of task over each kind of unit, minimizing data transfers between memory 
banks, performing data prefetching, etc. 
Expected advances: In a nutshell, a new runtime system API will be designed to 
allow applications to provide scheduling hints to the runtime system and to get 
real-time feedback about the consequences of scheduling decisions.
</p>
<hr>
<a name="Runtime-systems"></a>
<div class="header">
<p>
Next: <a href="#Linear-algebra" accesskey="n" rel="next">Linear algebra</a>, Previous: <a href="#Fine-interaction-between-linear-algebra-and-runtime-systems" accesskey="p" rel="prev">Fine interaction between linear algebra and runtime systems</a>, Up: <a href="#Research-fields" accesskey="u" rel="up">Research fields</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Runtime-systems-1"></a>
<h4 class="subsubsection">1.1.2.2 Runtime systems</h4>

<p>A runtime environment is an intermediate layer between the system and the 
application. 
It provides low-level functionality not provided by the system (such as 
scheduling or management of the heterogeneity) and high-level features (such as 
performance portability). 
In the framework of this proposal, we will work on the scalability of runtime 
environment. To achieve scalability it is required to avoid all centralization. 
Here, the main problem is the scheduling of the tasks. 
In many task-based runtime environments the scheduler is centralized and 
becomes a bottleneck as soon as too many cores are involved. 
It is therefore required to distribute the scheduling decision or to compute a 
data distribution that impose the mapping of task using, for instance the 
so-called &ldquo;owner-compute&rdquo; rule. 
Expected advances: We will design runtime systems that enable an efficient and 
scalable use of thousands of distributed multicore nodes enhanced with 
accelerators.
</p>
<hr>
<a name="Linear-algebra"></a>
<div class="header">
<p>
Previous: <a href="#Runtime-systems" accesskey="p" rel="prev">Runtime systems</a>, Up: <a href="#Research-fields" accesskey="u" rel="up">Research fields</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Linear-algebra-1"></a>
<h4 class="subsubsection">1.1.2.3 Linear algebra</h4>

<p>Because of its central position in HPC and of the well understood structure of 
its algorithms, dense linear algebra has often pioneered new challenges that HPC 
had to face. 
Again, dense linear algebra has been in the vanguard of the new era of 
petascale computing with the design of new algorithms that can efficiently run 
on a multicore node with GPU accelerators. These algorithms are called 
&ldquo;communication-avoiding&rdquo; since they have been redesigned to limit the amount 
of communication between processing units (and between the different levels of 
memory hierarchy). 
They are expressed through Direct Acyclic Graphs (DAG) of fine-grained tasks 
that are dynamically scheduled. Expected advances: First, we plan to investigate 
the impact of these principles in the case of sparse applications (whose 
algorithms are slightly more complicated but often rely on dense kernels). 
Furthermore, both in the dense and sparse cases, the scalability on thousands of 
nodes is still limited; new numerical approaches need to be found. 
We will specifically design sparse hybrid direct/iterative methods that 
represent a promising approach.
</p>
<hr>
<a name="Research-papers"></a>
<div class="header">
<p>
Previous: <a href="#Research-fields" accesskey="p" rel="prev">Research fields</a>, Up: <a href="#MORSE-project" accesskey="u" rel="up">MORSE project</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Research-papers-1"></a>
<h4 class="subsection">1.1.3 Research papers</h4>

<p>Research papers about MORSE can be found at
</p>
<p><a href="http://icl.cs.utk.edu/projectsdev/morse/pubs/index.html">http://icl.cs.utk.edu/projectsdev/morse/pubs/index.html</a>
</p>

<hr>
<a name="CHAMELEON"></a>
<div class="header">
<p>
Previous: <a href="#MORSE-project" accesskey="p" rel="prev">MORSE project</a>, Up: <a href="#Introduction" accesskey="u" rel="up">Introduction</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="CHAMELEON-1"></a>
<h3 class="section">1.2 CHAMELEON</h3>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#CHAMELEON-software" accesskey="1">CHAMELEON software</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">content and objectives
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#PLASMA_0027s-design-principles" accesskey="2">PLASMA's design principles</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">algorithmic and matrix layout
</td></tr>
</table>

<hr>
<a name="CHAMELEON-software"></a>
<div class="header">
<p>
Next: <a href="#PLASMA_0027s-design-principles" accesskey="n" rel="next">PLASMA's design principles</a>, Up: <a href="#CHAMELEON" accesskey="u" rel="up">CHAMELEON</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="CHAMELEON-software-1"></a>
<h4 class="subsection">1.2.1 CHAMELEON software</h4>

<p>The main purpose is to address the performance shortcomings of 
the <a href="http://www.netlib.org/lapack/">LAPACK</a>
and <a href="http://www.netlib.org/scalapack/">ScaLAPACK</a>
libraries on multicore processors and multi-socket systems of multicore 
processors and their inability to efficiently utilize accelerators such as 
Graphics Processing Units (GPUs).
</p>
<p>CHAMELEON is a framework written in C which provides routines to solve dense 
general systems of linear equations, symmetric positive definite systems of 
linear equations and linear least squares problems, using LU, Cholesky, QR and 
LQ factorizations.
Real arithmetic and complex arithmetic are supported in both single precision 
and double precision.
It supports Linux and Mac OS/X machines (only tested on Intel x86-64 
architecture).
</p>
<p>CHAMELEON is based on <a href="http://icl.cs.utk.edu/plasma/">PLASMA</a> source 
code but is not limited to shared-memory environment and can exploit 
multiple GPUs.
CHAMELEON is interfaced in a generic way with both 
<a href="http://icl.cs.utk.edu/quark/">QUARK</a> and 
<a href="http://runtime.bordeaux.inria.fr/StarPU/">StarPU</a> runtime systems.
This feature allows to analyze in a unified framework how sequential 
task-based algorithms behave regarding different runtime systems 
implementations. 
Using CHAMELEON with <a href="http://runtime.bordeaux.inria.fr/StarPU/">StarPU</a> runtime system allows to exploit GPUs through 
kernels provided by <a href="https://developer.nvidia.com/cublas">cuBLAS</a> and 
<a href="http://icl.cs.utk.edu/magma/">MAGMA</a> and clusters of interconnected 
nodes with distributed memory (using <a href="http://www.open-mpi.org/">MPI</a>).
Computation of very large systems with dense matrices on a cluster of nodes is 
still being experimented and stabilized.
It is not expected to get stable performances with the current version using 
MPI.
</p>


<hr>
<a name="PLASMA_0027s-design-principles"></a>
<div class="header">
<p>
Previous: <a href="#CHAMELEON-software" accesskey="p" rel="prev">CHAMELEON software</a>, Up: <a href="#CHAMELEON" accesskey="u" rel="up">CHAMELEON</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="PLASMA_0027s-design-principles-1"></a>
<h4 class="subsection">1.2.2 PLASMA&rsquo;s design principles</h4>

<p>CHAMELEON is originally based on <a href="http://icl.cs.utk.edu/plasma/">PLASMA</a> so that design principles are very similar. 
The content of this section <a href="#PLASMA_0027s-design-principles">PLASMA's design principles</a> has been copied 
from the &lsquo;<samp>Design principles</samp>&rsquo; section of the PLASMA User&rsquo;s Guide.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Tile-Algorithms" accesskey="1">Tile Algorithms</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Tile-Data-Layout" accesskey="2">Tile Data Layout</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Dynamic-Task-Scheduling" accesskey="3">Dynamic Task Scheduling</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Tile-Algorithms"></a>
<div class="header">
<p>
Next: <a href="#Tile-Data-Layout" accesskey="n" rel="next">Tile Data Layout</a>, Up: <a href="#PLASMA_0027s-design-principles" accesskey="u" rel="up">PLASMA's design principles</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Tile-Algorithms-1"></a>
<h4 class="subsubsection">1.2.2.1 Tile Algorithms</h4>

<p>Tile algorithms are based on the idea of processing the matrix by square tiles 
of relatively small size, such that a tile fits entirely in one of the cache 
levels associated with one core.
This way a tile can be loaded to the cache and processed completely before being 
evicted back to the main memory.
Of the three types of cache misses, <em>compulsory</em>, <em>capacity</em> 
and <em>conflict</em>, the use of tile algorithms minimizes the number of 
capacity misses, since each operation loads the amount of data that does not 
&ldquo;overflow&rdquo; the cache.
</p>
<p>For some operations such as matrix multiplication and Cholesky factorization, 
translating the classic algorithm to the tile algorithm is trivial.
In the case of matrix multiplication, the tile algorithm is simply a product of 
applying the technique of <em>loop tiling</em> to the canonical definition of 
three nested loops.
It is very similar for the Cholesky factorization.
The <strong>left-looking</strong> definition of Cholesky factorization from LAPACK is a 
loop with a sequence of calls to four routines: xSYRK (symmetric 
<strong>rank-k</strong> update), xPOTRF (Cholesky factorization of a small block on the 
diagonal), xGEMM (matrix multiplication) and xTRSM (triangular solve).
If the xSYRK, xGEMM and xTRSM operations are expressed with the canonical 
definition of three nested loops and the technique of loop tiling is applied, 
the tile algorithm results.
Since the algorithm is produced by simple reordering of operations, neither the 
number of operations nor numerical stability of the algorithm are affected.
</p>
<p>The situation becomes slightly more complicated for LU and QR factorizations, 
where the classic algorithms factorize an entire panel of the matrix (a block 
of columns) at every step of the algorithm.
One can observe, however, that the process of matrix factorization is 
synonymous with introducing zeros in approproate places and a tile algorithm 
can be fought of as one that zeroes one tile of the matrix at a time.
This process is referred to as updating of a factorization or <em>incremental 
factorization</em>.
The process is equivalent to factorizing the top tile of a panel, then placing 
the upper triangle of the result on top of the tile blow and factorizing again, 
then moving to the next tile and so on.
Here, the tile LU and QR algorithms perform slightly more floating point 
operations and require slightly more memory for auxiliary data.
Also, the tile LU factorization applies a different pivoting pattern and, as a 
result, is less numerically stable than classic LU with full pivoting.
Numerical stability is not an issue in case of the tile QR, which relies on 
orthogonal transformations (Householder reflections), which are numerically 
stable.
</p>
<div align="center"><img src="tile_lu.jpg" alt="tile_lu">
</div>
<p>Schematic illustration of the tile LU factorization (kernel names for 
real arithmetics in double precision), courtesey of the 
<a href="http://icl.cs.utk.edu/plasma/">PLASMA</a> team.
</p>

<hr>
<a name="Tile-Data-Layout"></a>
<div class="header">
<p>
Next: <a href="#Dynamic-Task-Scheduling" accesskey="n" rel="next">Dynamic Task Scheduling</a>, Previous: <a href="#Tile-Algorithms" accesskey="p" rel="prev">Tile Algorithms</a>, Up: <a href="#PLASMA_0027s-design-principles" accesskey="u" rel="up">PLASMA's design principles</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Tile-Data-Layout-1"></a>
<h4 class="subsubsection">1.2.2.2 Tile Data Layout</h4>

<p>Tile layout is based on the idea of storing the matrix by square tiles 
of relatively small size, such that each tile occupies a continuous memory 
region.
This way a tile can be loaded to the cache memory efficiently and the risk of 
evicting it from the cache memory before it is completely processed is 
minimized.
Of the three types of cache misses, <em>compulsory</em>, <em>capacity</em> and 
<em>conflict</em>, the use of tile layout minimizes the number of conflict 
misses, since a continuous region of memory will completely fill out a 
<strong>set-associative</strong> cache memory before an eviction can happen.
Also, from the standpoint of multithreaded execution, the probability of 
<em>false sharing</em> is minimized. 
It can only affect the cache lines containing the beginning and the ending of a 
tile.
</p>
<p>In standard <strong>cache-based</strong> architecture, tiles continously laid out in 
memory maximize the profit from automatic prefetching.
Tile layout is also beneficial in situations involving the use of accelerators, 
where explicit communication of tiles through DMA transfers is required, such as
moving tiles between the system memory and the local store in Cell B. E. or 
moving tiles between the host memory and the device memory in GPUs.
In most circumstances tile layout also minimizes the number of TLB 
misses and conflicts to memory banks or partitions.
With the standard (<strong>column-major</strong>) layout, access to each column of 
a tile is much more likely
to cause a conflict miss, a false sharing miss, a TLB miss or a bank 
or partition conflict.
The use of the standard layout for dense matrix operations is a 
performance minefield.
Although occasionally one can pass through it unscathed, the risk of hitting a 
spot deadly to performance is very high.
</p>
<p>Another property of the layout utilized in PLASMA is that it is &ldquo;flat&rdquo;, 
meaning that it does not involve a level of indirection. Each tile stores a 
small square submatrix of the main matrix in a <strong>column-major</strong> layout. In 
turn, the main matrix is an arrangement of tiles immediately following one 
another in a <strong>column-major</strong> layout.
The offset of each tile can be calculated through address arithmetics and 
does not involve pointer indirection.
Alternatively, a matrix could be represented as an array of pointers to 
tiles, located anywhere in memory. Such layout would be a radical 
and unjustifiable departure from LAPACK and ScaLAPACK.
Flat tile layout is a natural progression from LAPACK&rsquo;s <strong>column-major</strong> 
layout and ScaLAPACK&rsquo;s <strong>block-cyclic</strong> layout.
</p>
<p>Another related property of PLASMA&rsquo;s tile layout is that it includes 
provisions for padding of tiles, i.e., the actual region of memory designated 
for a tile can be larger than the memory occupied by the actual data.
This allows to force a certain alignment of tile boundaries, while using the 
flat organization described in the previous paragraph.
The motivation is that, at the price of small memory overhead, alignment of 
tile boundaries may prove benefivial in multiple scenarios involving 
memory systems of standard multicore processors, as well as accelerators. 
The issues that come into play are, again, the use of TLBs and memory banks or 
partitions.
</p>
<div align="center"><img src="tile_layout.jpg" alt="tile_layout">
</div>
<p>Schematic illustration of the tile layout with <strong>column-major</strong> 
order of tiles, <strong>column-major</strong> order of elements within tiles and 
(optional) padding for enforcing a certain alighment of tile bondaries, 
courtesey of the <a href="http://icl.cs.utk.edu/plasma/">PLASMA</a> team.
</p>

<hr>
<a name="Dynamic-Task-Scheduling"></a>
<div class="header">
<p>
Previous: <a href="#Tile-Data-Layout" accesskey="p" rel="prev">Tile Data Layout</a>, Up: <a href="#PLASMA_0027s-design-principles" accesskey="u" rel="up">PLASMA's design principles</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Dynamic-Task-Scheduling-1"></a>
<h4 class="subsubsection">1.2.2.3 Dynamic Task Scheduling</h4>

<p>Dynamic scheduling is the idea of assigning work to cores based on the 
availability of data for processing at any given point in time and is also 
referred to as <strong><em>data-driven</em></strong> scheduling.
The concept is related closely to the idea of expressing computation through a 
task graph, often referred to as the DAG (<em>Direct Acyclic Graph</em>), and 
the flexibility exploring the DAG at runtime.
Thus, to a large extent, dynamic scheduling is synonymous with 
<strong><em>runtime scheduling</em></strong>.
An important concept here is the one of the <em>critical path</em>, which defines 
the upper bound on the achievable parallelism, and needs to be pursued at the 
maximum speed.
This is in direct opposition to the <strong><em>fork-and-join</em></strong> or 
<strong><em>data-parallel</em></strong> programming models, where 
artificial synchronization points expose serial sections of
the code, where multiple cores are idle, while sequential processing takes 
place.
The use of dynamic scheduling introduces a <strong>trade-off</strong>, though.
The more dynamic (flexible) scheduling is, the more centralized (and less 
scalable) the scheduling mechanism is.
For that reason, currently PLASMA uses two scheduling 
mechanisms, one which is fully dynamic and one where work is assigned 
statically and dependency checks are done at runtime.
</p>
<p>The first scheduling mechanism relies on unfolding a <em>sliding window</em> of 
the task graph at runtime and scheduling work by resolving data hazards: 
<em>Read After Write~(RAW)</em>, <em>Write After Read~(WAR)</em> and <em>Write 
After Write~(WAW)</em>, a technique analogous to instruction scheduling in 
superscalar processors.
It also relies on <strong><em>work-stealing</em></strong> for balanding the 
load among all multiple cores.
The second scheduling mechanism relies on statically designating a path through 
the execution space of the algorithm to each core and following a 
cycle: transition to a task, wait for its dependencies, execute it, update the 
overall progress.
Task are identified by tuples and task transitions are done through locally 
evaluated formulas.
Progress information can be centralized, replicated or distributed (currently 
centralized).
</p>
<div align="center"><img src="trace_qr.jpg" alt="trace_qr">
</div>
<p>A trace of the tile QR factorization executing on eight cores without 
any global synchronization points (kernel names for real arithmetics in single 
precision), courtesey of the <a href="http://icl.cs.utk.edu/plasma/">PLASMA</a> team.
</p>

<hr>
<a name="Installing-CHAMELEON"></a>
<div class="header">
<p>
Next: <a href="#Configuring-CHAMELEON" accesskey="n" rel="next">Configuring CHAMELEON</a>, Previous: <a href="#Introduction" accesskey="p" rel="prev">Introduction</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Installing-CHAMELEON-1"></a>
<h2 class="chapter">2 Installing CHAMELEON</h2>


<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Downloading-CHAMELEON" accesskey="1">Downloading CHAMELEON</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Build-process-of-CHAMELEON" accesskey="2">Build process of CHAMELEON</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<p>CHAMELEON can be built and installed by the standard means of CMake 
(<a href="http://www.cmake.org/">http://www.cmake.org/</a>).
General information about CMake, as well as installation binaries and CMake 
source code are available from 
<a href="http://www.cmake.org/cmake/resources/software.html">http://www.cmake.org/cmake/resources/software.html</a>.
The following chapter is intended to briefly remind how these tools can be used 
to install CHAMELEON.
</p>
<hr>
<a name="Downloading-CHAMELEON"></a>
<div class="header">
<p>
Next: <a href="#Build-process-of-CHAMELEON" accesskey="n" rel="next">Build process of CHAMELEON</a>, Up: <a href="#Installing-CHAMELEON" accesskey="u" rel="up">Installing CHAMELEON</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Downloading-CHAMELEON-1"></a>
<h3 class="section">2.1 Downloading CHAMELEON</h3>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Getting-Sources" accesskey="1">Getting Sources</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Required-dependencies" accesskey="2">Required dependencies</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Optional-dependencies" accesskey="3">Optional dependencies</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Getting-Sources"></a>
<div class="header">
<p>
Next: <a href="#Required-dependencies" accesskey="n" rel="next">Required dependencies</a>, Up: <a href="#Downloading-CHAMELEON" accesskey="u" rel="up">Downloading CHAMELEON</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Getting-Sources-1"></a>
<h4 class="subsection">2.1.1 Getting Sources</h4>

<p>The latest official release tarballs of CHAMELEON sources are available for 
download from 
<a href="http://morse.gforge.inria.fr/chameleon-0.9.1.tar.gz">chameleon-0.9.1</a>.
</p>

<hr>
<a name="Required-dependencies"></a>
<div class="header">
<p>
Next: <a href="#Optional-dependencies" accesskey="n" rel="next">Optional dependencies</a>, Previous: <a href="#Getting-Sources" accesskey="p" rel="prev">Getting Sources</a>, Up: <a href="#Downloading-CHAMELEON" accesskey="u" rel="up">Downloading CHAMELEON</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Required-dependencies-1"></a>
<h4 class="subsection">2.1.2 Required dependencies</h4>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#a-BLAS-implementation" accesskey="1">a BLAS implementation</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#CBLAS" accesskey="2">CBLAS</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#a-LAPACK-implementation" accesskey="3">a LAPACK implementation</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#LAPACKE" accesskey="4">LAPACKE</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#libtmg" accesskey="5">libtmg</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#QUARK" accesskey="6">QUARK</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#StarPU" accesskey="7">StarPU</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#hwloc" accesskey="8">hwloc</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#pthread" accesskey="9">pthread</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="a-BLAS-implementation"></a>
<div class="header">
<p>
Next: <a href="#CBLAS" accesskey="n" rel="next">CBLAS</a>, Up: <a href="#Required-dependencies" accesskey="u" rel="up">Required dependencies</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="a-BLAS-implementation-1"></a>
<h4 class="subsubsection">2.1.2.1 a BLAS implementation</h4>

<p><a href="http://www.netlib.org/blas/">BLAS</a> (Basic Linear Algebra Subprograms), 
are a de facto standard for basic linear algebra operations such as vector and 
matrix multiplication. 
FORTRAN implementation of BLAS is available from Netlib. 
Also, C implementation of BLAS is included in GSL (GNU Scientific Library). 
Both these implementations are reference implementation of BLAS, are not 
optimized for modern processor architectures and provide an order of magnitude 
lower performance than optimized implementations. 
Highly optimized implementations of BLAS are available from many hardware 
vendors, such as Intel MKL and AMD ACML. 
Fast implementations are also available as academic packages, such as ATLAS and 
Goto BLAS. 
The standard interface to BLAS is the FORTRAN interface.
</p>
<p><strong>Caution about the compatibility:</strong> CHAMELEON has been mainly tested with 
the reference BLAS from NETLIB and the Intel MKL 11.1 from Intel distribution 
2013_sp1.
</p>
<hr>
<a name="CBLAS"></a>
<div class="header">
<p>
Next: <a href="#a-LAPACK-implementation" accesskey="n" rel="next">a LAPACK implementation</a>, Previous: <a href="#a-BLAS-implementation" accesskey="p" rel="prev">a BLAS implementation</a>, Up: <a href="#Required-dependencies" accesskey="u" rel="up">Required dependencies</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="CBLAS-1"></a>
<h4 class="subsubsection">2.1.2.2 CBLAS</h4>

<p><a href="http://www.netlib.org/blas/#_cblas">CBLAS</a> is a C language interface to 
BLAS.
Most commercial and academic implementations of BLAS also provide CBLAS. 
Netlib provides a reference implementation of CBLAS on top of FORTRAN BLAS 
(Netlib CBLAS). 
Since GSL is implemented in C, it naturally provides CBLAS.
</p>
<p><strong>Caution about the compatibility:</strong> CHAMELEON has been mainly tested with 
the reference CBLAS from NETLIB and the Intel MKL 11.1 from Intel distribution 
2013_sp1.
</p>
<hr>
<a name="a-LAPACK-implementation"></a>
<div class="header">
<p>
Next: <a href="#LAPACKE" accesskey="n" rel="next">LAPACKE</a>, Previous: <a href="#CBLAS" accesskey="p" rel="prev">CBLAS</a>, Up: <a href="#Required-dependencies" accesskey="u" rel="up">Required dependencies</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="a-LAPACK-implementation-1"></a>
<h4 class="subsubsection">2.1.2.3 a LAPACK implementation</h4>

<p><a href="http://www.netlib.org/lapack/">LAPACK</a> (Linear Algebra PACKage) is a 
software library for numerical linear algebra, a successor of LINPACK and 
EISPACK and a predecessor of CHAMELEON. 
LAPACK provides routines for solving linear systems of equations, linear least 
square problems, eigenvalue problems and singular value problems. 
Most commercial and academic BLAS packages also provide some LAPACK routines.
</p>
<p><strong>Caution about the compatibility:</strong> CHAMELEON has been mainly tested with 
the reference LAPACK from NETLIB and the Intel MKL 11.1 from Intel distribution 
2013_sp1.
</p>
<hr>
<a name="LAPACKE"></a>
<div class="header">
<p>
Next: <a href="#libtmg" accesskey="n" rel="next">libtmg</a>, Previous: <a href="#a-LAPACK-implementation" accesskey="p" rel="prev">a LAPACK implementation</a>, Up: <a href="#Required-dependencies" accesskey="u" rel="up">Required dependencies</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="LAPACKE-1"></a>
<h4 class="subsubsection">2.1.2.4 LAPACKE</h4>

<p><a href="http://www.netlib.org/lapack/">LAPACKE</a> is a C language interface to 
LAPACK (or CLAPACK). 
It is produced by Intel in coordination with the LAPACK team and is available 
in source code from Netlib in its original version (Netlib LAPACKE) and from 
CHAMELEON website in an extended version (LAPACKE for CHAMELEON). 
In addition to implementing the C interface, LAPACKE also provides routines 
which automatically handle workspace allocation, making the use of LAPACK much 
more convenient.
</p>
<p><strong>Caution about the compatibility:</strong> CHAMELEON has been mainly tested with 
the reference LAPACKE from NETLIB. 
A stand-alone version of LAPACKE is required.
</p>
<hr>
<a name="libtmg"></a>
<div class="header">
<p>
Next: <a href="#QUARK" accesskey="n" rel="next">QUARK</a>, Previous: <a href="#LAPACKE" accesskey="p" rel="prev">LAPACKE</a>, Up: <a href="#Required-dependencies" accesskey="u" rel="up">Required dependencies</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="libtmg-1"></a>
<h4 class="subsubsection">2.1.2.5 libtmg</h4>

<p><a href="http://www.netlib.org/lapack/">libtmg</a> is a component of the LAPACK 
library, containing routines for generation 
of input matrices for testing and timing of LAPACK. 
The testing and timing suites of LAPACK require libtmg, but not the library 
itself. Note that the LAPACK library can be built and used without libtmg.
</p>
<p><strong>Caution about the compatibility:</strong> CHAMELEON has been mainly tested with 
the reference TMG from NETLIB and the Intel MKL 11.1 from Intel distribution 
2013_sp1.
</p>
<hr>
<a name="QUARK"></a>
<div class="header">
<p>
Next: <a href="#StarPU" accesskey="n" rel="next">StarPU</a>, Previous: <a href="#libtmg" accesskey="p" rel="prev">libtmg</a>, Up: <a href="#Required-dependencies" accesskey="u" rel="up">Required dependencies</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="QUARK-1"></a>
<h4 class="subsubsection">2.1.2.6 QUARK</h4>

<p><a href="http://icl.cs.utk.edu/quark/">QUARK</a> (QUeuing And Runtime for Kernels) 
provides a library that enables the dynamic execution of tasks with data 
dependencies in a multi-core, multi-socket, shared-memory environment. 
One of QUARK or StarPU Runtime systems has to be enabled in order to schedule 
tasks on the architecture.
If QUARK is enabled then StarPU is disabled and conversely.
Note StarPU is enabled by default.
When CHAMELEON is linked with QUARK, it is not possible to exploit neither 
CUDA (for GPUs) nor MPI (distributed-memory environment).
You can use StarPU to do so.
</p>
<p><strong>Caution about the compatibility:</strong> CHAMELEON has been mainly tested with 
the QUARK library from PLASMA release between versions 2.5.0 and 2.6.0.
</p>
<hr>
<a name="StarPU"></a>
<div class="header">
<p>
Next: <a href="#hwloc" accesskey="n" rel="next">hwloc</a>, Previous: <a href="#QUARK" accesskey="p" rel="prev">QUARK</a>, Up: <a href="#Required-dependencies" accesskey="u" rel="up">Required dependencies</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="StarPU-1"></a>
<h4 class="subsubsection">2.1.2.7 StarPU</h4>

<p><a href="http://runtime.bordeaux.inria.fr/StarPU/">StarPU</a> is a task programming 
library for hybrid architectures.
StarPU handles run-time concerns such as:
</p><ul>
<li> Task dependencies
</li><li> Optimized heterogeneous scheduling
</li><li> Optimized data transfers and replication between main memory and discrete 
memories
</li><li> Optimized cluster communications
</li></ul>
<p>StarPU can be used to benefit from GPUs and distributed-memory environment.
One of QUARK or StarPU runtime system has to be enabled in order to schedule 
tasks on the architecture.
If StarPU is enabled then QUARK is disabled and conversely.
Note StarPU is enabled by default.
</p>
<p><strong>Caution about the compatibility:</strong> CHAMELEON has been mainly tested with 
StarPU-1.1 releases.
</p>
<hr>
<a name="hwloc"></a>
<div class="header">
<p>
Next: <a href="#pthread" accesskey="n" rel="next">pthread</a>, Previous: <a href="#StarPU" accesskey="p" rel="prev">StarPU</a>, Up: <a href="#Required-dependencies" accesskey="u" rel="up">Required dependencies</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="hwloc-1"></a>
<h4 class="subsubsection">2.1.2.8 hwloc</h4>

<p><a href="http://www.open-mpi.org/projects/hwloc/">hwloc</a> (Portable Hardware 
Locality) is a software package for accessing the  topology of a multicore 
system including components like: cores, sockets, caches and NUMA nodes. 
It allows to increase performance, and to perform some topology aware 
scheduling.
<code>hwloc</code> is available in major distributions and for most OSes and can be  
downloaded from <a href="http://www.open-mpi.org/software/hwloc">http://www.open-mpi.org/software/hwloc</a>.
</p>
<p><strong>Caution about the compatibility:</strong> hwloc should be compatible with the 
version of StarPU used.
</p>
<hr>
<a name="pthread"></a>
<div class="header">
<p>
Previous: <a href="#hwloc" accesskey="p" rel="prev">hwloc</a>, Up: <a href="#Required-dependencies" accesskey="u" rel="up">Required dependencies</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="pthread-1"></a>
<h4 class="subsubsection">2.1.2.9 pthread</h4>

<p>POSIX threads library is required to run CHAMELEON on Unix-like systems. 
It is a standard component of any such system. 
</p>
<hr>
<a name="Optional-dependencies"></a>
<div class="header">
<p>
Previous: <a href="#Required-dependencies" accesskey="p" rel="prev">Required dependencies</a>, Up: <a href="#Downloading-CHAMELEON" accesskey="u" rel="up">Downloading CHAMELEON</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Optional-dependencies-1"></a>
<h4 class="subsection">2.1.3 Optional dependencies</h4>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#OpenMPI" accesskey="1">OpenMPI</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Nvidia-CUDA-Toolkit" accesskey="2">Nvidia CUDA Toolkit</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#MAGMA" accesskey="3">MAGMA</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#FxT" accesskey="4">FxT</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="OpenMPI"></a>
<div class="header">
<p>
Next: <a href="#Nvidia-CUDA-Toolkit" accesskey="n" rel="next">Nvidia CUDA Toolkit</a>, Up: <a href="#Optional-dependencies" accesskey="u" rel="up">Optional dependencies</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="OpenMPI-1"></a>
<h4 class="subsubsection">2.1.3.1 OpenMPI</h4>

<p><a href="http://www.open-mpi.org/">OpenMPI</a> is an open source Message Passing 
Interface implementation for execution on multiple nodes with 
distributed-memory environment.
MPI can be enabled only if the runtime system chosen is StarPU (default).
To use MPI through StarPU, it is necessary to compile StarPU with MPI 
enabled.
</p>
<p><strong>Caution about the compatibility:</strong> CHAMELEON has been mainly tested with 
OpenMPI releases from versions 1.4 to 1.6.
</p>
<hr>
<a name="Nvidia-CUDA-Toolkit"></a>
<div class="header">
<p>
Next: <a href="#MAGMA" accesskey="n" rel="next">MAGMA</a>, Previous: <a href="#OpenMPI" accesskey="p" rel="prev">OpenMPI</a>, Up: <a href="#Optional-dependencies" accesskey="u" rel="up">Optional dependencies</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Nvidia-CUDA-Toolkit-1"></a>
<h4 class="subsubsection">2.1.3.2 Nvidia CUDA Toolkit</h4>

<p><a href="https://developer.nvidia.com/cuda-toolkit">Nvidia CUDA Toolkit</a> provides 
a 
comprehensive development environment for C and C++ developers building 
GPU-accelerated applications. 
CHAMELEON can use a set of low level optimized kernels coming from cuBLAS to 
accelerate computations on GPUs.
The <a href="http://docs.nvidia.com/cuda/cublas/">cuBLAS</a> library is an 
implementation of BLAS (Basic Linear Algebra Subprograms) on top of the Nvidia 
CUDA runtime.
cuBLAS is normaly distributed with Nvidia CUDA Toolkit.
CUDA/cuBLAS can be enabled in CHAMELEON only if the runtime system chosen 
is StarPU (default).
To use CUDA through StarPU, it is necessary to compile StarPU with CUDA 
enabled.
</p>
<p><strong>Caution about the compatibility:</strong> CHAMELEON has been mainly tested with 
CUDA releases from versions 4 to 6. 
MAGMA library must be compatible with CUDA.
</p>
<hr>
<a name="MAGMA"></a>
<div class="header">
<p>
Next: <a href="#FxT" accesskey="n" rel="next">FxT</a>, Previous: <a href="#Nvidia-CUDA-Toolkit" accesskey="p" rel="prev">Nvidia CUDA Toolkit</a>, Up: <a href="#Optional-dependencies" accesskey="u" rel="up">Optional dependencies</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="MAGMA-1"></a>
<h4 class="subsubsection">2.1.3.3 MAGMA</h4>

<p><a href="http://icl.cs.utk.edu/magma/">MAGMA</a> project aims to develop a dense 
linear algebra library similar to LAPACK but for heterogeneous/hybrid 
architectures, starting with current &quot;Multicore+GPU&quot; systems.
CHAMELEON can use a set of high level MAGMA routines to accelerate 
computations on GPUs.
To fully benefit from GPUs, the user should enable MAGMA in addition to 
CUDA/cuBLAS.
</p>
<p><strong>Caution about the compatibility:</strong> CHAMELEON has been mainly tested with 
MAGMA releases from versions 1.4 to 1.6.
MAGMA library must be compatible with CUDA.
MAGMA library should be built with sequential versions of BLAS/LAPACK. 
We should not get some MAGMA link flags embarking multithreaded 
BLAS/LAPACK because it could affect permformances (take care about the 
MAGMA link flag <samp>-lmkl_intel_thread</samp> for example that we could heritate 
from the pkg-config file <samp>magma.pc</samp>).
</p>
<hr>
<a name="FxT"></a>
<div class="header">
<p>
Previous: <a href="#MAGMA" accesskey="p" rel="prev">MAGMA</a>, Up: <a href="#Optional-dependencies" accesskey="u" rel="up">Optional dependencies</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="FxT-1"></a>
<h4 class="subsubsection">2.1.3.4 FxT</h4>

<p><a href="http://download.savannah.gnu.org/releases/fkt/">FxT</a> stands for both 
FKT (Fast Kernel Tracing) and FUT (Fast User Tracing). 
This library provides efficient support for recording traces.
CHAMELEON can trace kernels execution on the different workers and produce 
.paje files if FxT is enabled. 
FxT can only be used through StarPU and StarPU must be compiled with FxT 
enabled, see how to use this feature here <a href="#Use-FxT-profiling-through-StarPU">Use FxT profiling through StarPU</a>.
</p>
<p><strong>Caution about the compatibility:</strong> FxT should be compatible with the 
version of StarPU used.
</p>
<hr>
<a name="Build-process-of-CHAMELEON"></a>
<div class="header">
<p>
Previous: <a href="#Downloading-CHAMELEON" accesskey="p" rel="prev">Downloading CHAMELEON</a>, Up: <a href="#Installing-CHAMELEON" accesskey="u" rel="up">Installing CHAMELEON</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Build-process-of-CHAMELEON-1"></a>
<h3 class="section">2.2 Build process of CHAMELEON</h3>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Setting-up-a-build-directory" accesskey="1">Setting up a build directory</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Configuring-the-project-with-best-efforts" accesskey="2">Configuring the project with best efforts</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Building" accesskey="3">Building</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Tests" accesskey="4">Tests</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Installing" accesskey="5">Installing</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Setting-up-a-build-directory"></a>
<div class="header">
<p>
Next: <a href="#Configuring-the-project-with-best-efforts" accesskey="n" rel="next">Configuring the project with best efforts</a>, Up: <a href="#Build-process-of-CHAMELEON" accesskey="u" rel="up">Build process of CHAMELEON</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Setting-up-a-build-directory-1"></a>
<h4 class="subsection">2.2.1 Setting up a build directory</h4>

<p>The CHAMELEON build process requires CMake version 2.8.0 or higher and 
working C and Fortran compilers.
Compilation and link with CHAMELEON libraries have been tested with 
<strong>gcc/gfortran 4.8.1</strong> and <strong>icc/ifort 14.0.2</strong>.
On Unix-like operating systems, it also requires Make.
The CHAMELEON project can not be configured for an in-source build. 
You will get an error message if you try to compile in-source. 
Please clean the root of your project by deleting the generated 
<samp>CMakeCache.txt</samp> file (and other CMake generated files).
</p>
<div class="example">
<pre class="example">mkdir build
cd build
</pre></div>

<blockquote>
<p>You can create a build directory from any location you would like. It can be a 
sub-directory of the CHAMELEON base source directory or anywhere else.
</p></blockquote>

<hr>
<a name="Configuring-the-project-with-best-efforts"></a>
<div class="header">
<p>
Next: <a href="#Building" accesskey="n" rel="next">Building</a>, Previous: <a href="#Setting-up-a-build-directory" accesskey="p" rel="prev">Setting up a build directory</a>, Up: <a href="#Build-process-of-CHAMELEON" accesskey="u" rel="up">Build process of CHAMELEON</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Configuring-the-project-with-best-efforts-1"></a>
<h4 class="subsection">2.2.2 Configuring the project with best efforts</h4>

<div class="example">
<pre class="example">cmake &lt;path to SOURCE_DIR&gt; -DOPTION1= -DOPTION2= ...
</pre></div>
<p><samp>&lt;path to SOURCE_DIR&gt;</samp> represents the root of CHAMELEON project where 
stands 
the main (parent) <samp>CMakeLists.txt</samp> file.
Details about options that are useful to give to <code>cmake &lt;path to 
SOURCE_DIR&gt;</code> are given in <a href="#Compilation-configuration">Compilation configuration</a>.
</p>
<hr>
<a name="Building"></a>
<div class="header">
<p>
Next: <a href="#Tests" accesskey="n" rel="next">Tests</a>, Previous: <a href="#Configuring-the-project-with-best-efforts" accesskey="p" rel="prev">Configuring the project with best efforts</a>, Up: <a href="#Build-process-of-CHAMELEON" accesskey="u" rel="up">Build process of CHAMELEON</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Building-1"></a>
<h4 class="subsection">2.2.3 Building</h4>

<div class="example">
<pre class="example">make [-j[ncores]]
</pre></div>
<p>do not hesitate to use <samp>-j[ncores]</samp> option to speedup the compilation
</p>
<hr>
<a name="Tests"></a>
<div class="header">
<p>
Next: <a href="#Installing" accesskey="n" rel="next">Installing</a>, Previous: <a href="#Building" accesskey="p" rel="prev">Building</a>, Up: <a href="#Build-process-of-CHAMELEON" accesskey="u" rel="up">Build process of CHAMELEON</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Tests-1"></a>
<h4 class="subsection">2.2.4 Tests</h4>

<p>In order to make sure that CHAMELEON is working properly on the system, it is 
also possible to run a test suite.
</p>
<div class="example">
<pre class="example">make check
</pre></div>
<p>or
</p><div class="example">
<pre class="example">ctest
</pre></div>

<hr>
<a name="Installing"></a>
<div class="header">
<p>
Previous: <a href="#Tests" accesskey="p" rel="prev">Tests</a>, Up: <a href="#Build-process-of-CHAMELEON" accesskey="u" rel="up">Build process of CHAMELEON</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Installing-1"></a>
<h4 class="subsection">2.2.5 Installing</h4>

<p>In order to install CHAMELEON at the location that was specified during 
configuration:
</p>
<div class="example">
<pre class="example">make install
</pre></div>
<p>do not forget to specify the install directory with 
<samp>-DCMAKE_INSTALL_PREFIX</samp> at cmake configure
</p><div class="example">
<pre class="example">cmake &lt;path to SOURCE_DIR&gt; -DCMAKE_INSTALL_PREFIX=&lt;path to INSTALL_DIR&gt;
</pre></div>
<p>Note that the install process is optional.
You are free to use CHAMELEON binaries compiled in the build directory.
</p>

<hr>
<a name="Configuring-CHAMELEON"></a>
<div class="header">
<p>
Next: <a href="#Using-CHAMELEON" accesskey="n" rel="next">Using CHAMELEON</a>, Previous: <a href="#Installing-CHAMELEON" accesskey="p" rel="prev">Installing CHAMELEON</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Configuring-CHAMELEON-1"></a>
<h2 class="chapter">3 Configuring CHAMELEON</h2>


<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Compilation-configuration" accesskey="1">Compilation configuration</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Dependencies-detection" accesskey="2">Dependencies detection</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Use-FxT-profiling-through-StarPU" accesskey="3">Use FxT profiling through StarPU</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Use-simulation-mode-with-StarPU_002dSimGrid" accesskey="4">Use simulation mode with StarPU-SimGrid</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>


<hr>
<a name="Compilation-configuration"></a>
<div class="header">
<p>
Next: <a href="#Dependencies-detection" accesskey="n" rel="next">Dependencies detection</a>, Up: <a href="#Configuring-CHAMELEON" accesskey="u" rel="up">Configuring CHAMELEON</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Compilation-configuration-1"></a>
<h3 class="section">3.1 Compilation configuration</h3>

<p>The following arguments can be given to the <code>cmake &lt;path to source 
directory&gt;</code> script.
</p>
<p>In this chapter, the following convention is used:
</p><ul>
<li> <samp>path</samp> is a path in your filesystem,
</li><li> <samp>var</samp> is a string and the correct value or an example will be given,
</li><li> <samp>trigger</samp> is an CMake option and the correct value is <code>ON</code> or 
<code>OFF</code>.
</li></ul>

<p>Using CMake there are several ways to give options:
</p><ol>
<li> directly as CMake command line arguments
</li><li> invoque <code>cmake &lt;path to source directory&gt;</code> once and then use 
<code>ccmake &lt;path to source directory&gt;</code> to edit options through a 
minimalist gui (required 
&lsquo;<samp>cmake-curses-gui</samp>&rsquo; installed on a Linux system)
</li><li> invoque <code>cmake-gui</code> command and fill information about the 
location of the sources and where to build the project, then you have 
access to options through a user-friendly Qt interface (required 
&lsquo;<samp>cmake-qt-gui</samp>&rsquo; installed on a Linux system)
</li></ol>

<p>Example of configuration using the command line 
</p><div class="example">
<pre class="example">cmake ~/chameleon/ -DCMAKE_BUILD_TYPE=Debug          \
                   -DCMAKE_INSTALL_PREFIX=~/install  \
                   -DCHAMELEON_USE_CUDA=ON           \
                   -DCHAMELEON_USE_MAGMA=ON          \
                   -DCHAMELEON_USE_MPI=ON            \
                   -DBLA_VENDOR=Intel10_64lp         \
                   -DSTARPU_DIR=~/install/starpu-1.1 \                
                   -DCHAMELEON_USE_FXT=ON 
</pre></div>

<p>You can get the full list of options with <samp>-L[A][H]</samp> options of 
<code>cmake</code> command:
</p><div class="example">
<pre class="example">cmake -LH &lt;path to source directory&gt;
</pre></div>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#General-CMake-options" accesskey="1">General CMake options</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#CHAMELEON-options" accesskey="2">CHAMELEON options</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="General-CMake-options"></a>
<div class="header">
<p>
Next: <a href="#CHAMELEON-options" accesskey="n" rel="next">CHAMELEON options</a>, Up: <a href="#Compilation-configuration" accesskey="u" rel="up">Compilation configuration</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="General-CMake-options-1"></a>
<h4 class="subsection">3.1.1 General CMake options</h4>

<dl compact="compact">
<dt><code>-DCMAKE_INSTALL_PREFIX=<samp>path</samp> (default:<samp>path=/usr/local</samp>)</code></dt>
<dd><p>Install directory used by <code>make install</code> where some headers and libraries 
will be copied.
Permissions have to be granted to write onto <samp>path</samp> during <code>make 
install</code> step.
</p>
</dd>
<dt><code>-DCMAKE_BUILD_TYPE=<samp>var</samp> (default: <samp>Release</samp>)</code></dt>
<dd><p>Define the build type and the compiler optimization level.
The possible values for <samp>var</samp> are: 
</p><dl compact="compact">
<dt><code>empty</code></dt>
<dt><code>Debug</code></dt>
<dt><code>Release</code></dt>
<dt><code>RelWithDebInfo</code></dt>
<dt><code>MinSizeRel</code></dt>
</dl>

</dd>
<dt><code>-DBUILD_SHARED_LIBS=<samp>trigger</samp> (default:<samp>OFF</samp>)</code></dt>
<dd><p>Indicate wether or not CMake has to build CHAMELEON static (<samp>OFF</samp>) or 
shared (<samp>ON</samp>) libraries.
</p>
</dd>
</dl>

<hr>
<a name="CHAMELEON-options"></a>
<div class="header">
<p>
Previous: <a href="#General-CMake-options" accesskey="p" rel="prev">General CMake options</a>, Up: <a href="#Compilation-configuration" accesskey="u" rel="up">Compilation configuration</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="CHAMELEON-options-1"></a>
<h4 class="subsection">3.1.2 CHAMELEON options</h4>

<p>List of CHAMELEON options that can be enabled/disabled (value=<code>ON</code> 
or <code>OFF</code>):
</p><dl compact="compact">
<dt><code><samp>-DCHAMELEON_SCHED_STARPU</samp>=<samp>trigger</samp> (default: <code>ON</code>)</code></dt>
<dd><p>to link with StarPU library (runtime system)
</p>
</dd>
<dt><code><samp>-DCHAMELEON_SCHED_QUARK</samp>=<samp>trigger</samp> (default: <code>OFF</code>)</code></dt>
<dd><p>to link with QUARK library (runtime system)
</p>
</dd>
<dt><code><samp>-DCHAMELEON_USE_CUDA</samp>=<samp>trigger</samp> (default: <code>OFF</code>)</code></dt>
<dd><p>to link with CUDA runtime (implementation paradigm for accelerated codes on 
GPUs) and cuBLAS library (optimized BLAS kernels on GPUs), can only be used with 
StarPU
</p></dd>
<dt><code><samp>-DCHAMELEON_USE_MAGMA</samp>=<samp>trigger</samp> (default: <code>OFF</code>)</code></dt>
<dd><p>to link with MAGMA library (kernels on GPUs, higher level than cuBLAS), can only 
be used with StarPU
</p>
</dd>
<dt><code><samp>-DCHAMELEON_USE_MPI</samp>=<samp>trigger</samp> (default: <code>OFF</code>)</code></dt>
<dd><p>to link with MPI library (message passing implementation for use of multiple 
nodes with distributed memory), can only be used with StarPU
</p>
</dd>
<dt><code><samp>-DCHAMELEON_USE_FXT</samp>=<samp>trigger</samp> (default: <code>OFF</code>)</code></dt>
<dd><p>to link with FxT library (trace execution of kernels on workers), can only be 
used with StarPU
</p>
</dd>
<dt><code><samp>-DCHAMELEON_SIMULATION=trigger</samp> (default: <code>OFF</code>)</code></dt>
<dd><p>to enable simulation mode, means CHAMELEON will not really execute tasks, 
see details in section <a href="#Use-simulation-mode-with-StarPU_002dSimGrid">Use simulation mode with StarPU-SimGrid</a>. 
This option must be used with StarPU compiled with  
<a href="http://simgrid.gforge.inria.fr/">SimGrid</a> allowing to guess the 
execution time on any architecture.
This feature should be used to make experiments on the scheduler behaviors and 
performances not to produce solutions of linear systems.
</p>
</dd>
<dt><code><samp>-DCHAMELEON_ENABLE_DOCS=trigger</samp> (default: <code>ON</code>)</code></dt>
<dd><p>to control build of the documentation contained in <samp>docs/</samp> sub-directory
</p></dd>
<dt><code><samp>-DCHAMELEON_ENABLE_EXAMPLE=trigger</samp> (default: <code>ON</code>)</code></dt>
<dd><p>to control build of the examples executables (API usage) 
contained in <samp>example/</samp> sub-directory
</p></dd>
<dt><code><samp>-DCHAMELEON_ENABLE_TESTING=trigger</samp> (default: <code>ON</code>)</code></dt>
<dd><p>to control build of testing executables (numerical check) contained in 
<samp>testing/</samp> sub-directory
</p></dd>
<dt><code><samp>-DCHAMELEON_ENABLE_TIMING=trigger</samp> (default: <code>ON</code>)</code></dt>
<dd><p>to control build of timing executables (performances check) contained in 
<samp>timing/</samp> sub-directory
</p>
</dd>
<dt><code><samp>-DCHAMELEON_PREC_S=trigger</samp> (default: <code>ON</code>)</code></dt>
<dd><p>to enable the support of simple arithmetic precision (float in C)
</p></dd>
<dt><code><samp>-DCHAMELEON_PREC_D=trigger</samp> (default: <code>ON</code>)</code></dt>
<dd><p>to enable the support of double arithmetic precision (double in C)
</p></dd>
<dt><code><samp>-DCHAMELEON_PREC_C=trigger</samp> (default: <code>ON</code>)</code></dt>
<dd><p>to enable the support of complex arithmetic precision (complex in C)
</p></dd>
<dt><code><samp>-DCHAMELEON_PREC_Z=trigger</samp> (default: <code>ON</code>)</code></dt>
<dd><p>to enable the support of double complex arithmetic precision (double complex 
in C)
</p>
</dd>
<dt><code><samp>-DBLAS_VERBOSE=trigger</samp> (default: <code>OFF</code>)</code></dt>
<dd><p>to make BLAS library discovery verbose
</p></dd>
<dt><code><samp>-DLAPACK_VERBOSE=trigger</samp> (default: <code>OFF</code>)</code></dt>
<dd><p>to make LAPACK library discovery verbose (automatically enabled if 
<samp>BLAS_VERBOSE=<code>ON</code></samp>)
</p></dd>
</dl>

<p>List of CHAMELEON options that needs a specific value:
</p><dl compact="compact">
<dt><code><samp>-DBLA_VENDOR=<samp>var</samp></samp> (default: <samp>empty</samp>)</code></dt>
<dd><p>The possible values for <samp>var</samp> are:
</p><dl compact="compact">
<dt><code>empty</code></dt>
<dt><code>all</code></dt>
<dt><code>Intel10_64lp</code></dt>
<dt><code>Intel10_64lp_seq</code></dt>
<dt><code>ACML</code></dt>
<dt><code>Apple</code></dt>
<dt><code>Generic</code></dt>
<dt><code>...</code></dt>
</dl>
<p>to force CMake to find a specific BLAS library, see the full list of BLA_VENDOR 
in <samp>FindBLAS.cmake</samp> in <samp>cmake_modules/morse/find</samp>.
By default <samp>BLA_VENDOR</samp> is empty so that CMake tries to detect all 
possible BLAS vendor with a preference for Intel MKL.
</p></dd>
</dl>

<p>List of CHAMELEON options which requires to give a path:
</p><dl compact="compact">
<dt><code><samp>-DLIBNAME_DIR=<samp>path</samp></samp> (default: empty)</code></dt>
<dd><p>root directory of the LIBNAME library installation
</p></dd>
<dt><code><samp>-DLIBNAME_INCDIR=<samp>path</samp></samp> (default: empty)</code></dt>
<dd><p>directory of the LIBNAME library headers installation
</p></dd>
<dt><code><samp>-DLIBNAME_LIBDIR=<samp>path</samp></samp> (default: empty)</code></dt>
<dd><p>directory of the LIBNAME libraries (.so, .a, .dylib, etc) installation
</p></dd>
</dl>
<p>LIBNAME can be one of the following: BLAS - CBLAS - FXT - HWLOC - 
LAPACK - LAPACKE - MAGMA - QUARK - STARPU - TMG.
See paragraph about <a href="#Dependencies-detection">Dependencies detection</a> for details.
</p>
<p>Libraries detected with an official CMake module (see module files in 
<samp>CMAKE_ROOT/Modules/</samp>):
</p><ul>
<li> CUDA
</li><li> MPI
</li><li> Threads
</li></ul>

<p>Libraries detected with CHAMELEON cmake modules (see module files in 
<samp>cmake_modules/morse/find/</samp> directory of CHAMELEON sources):
</p><ul>
<li> BLAS
</li><li> CBLAS
</li><li> FXT
</li><li> HWLOC
</li><li> LAPACK
</li><li> LAPACKE
</li><li> MAGMA
</li><li> QUARK
</li><li> STARPU
</li><li> TMG 
</li></ul>


<hr>
<a name="Dependencies-detection"></a>
<div class="header">
<p>
Next: <a href="#Use-FxT-profiling-through-StarPU" accesskey="n" rel="next">Use FxT profiling through StarPU</a>, Previous: <a href="#Compilation-configuration" accesskey="p" rel="prev">Compilation configuration</a>, Up: <a href="#Configuring-CHAMELEON" accesskey="u" rel="up">Configuring CHAMELEON</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Dependencies-detection-1"></a>
<h3 class="section">3.2 Dependencies detection</h3>
<p>You have different choices to detect dependencies on your system, either by 
setting some environment variables containing paths to the libs and headers or 
by specifying them directly at cmake configure. 
Different cases :
</p><ol>
<li> detection of dependencies through environment variables: 
  <ul>
<li> <code>LD_LIBRARY_PATH</code> environment variable should contain the list of 
paths 
where to find the libraries:
    <div class="example">
<pre class="example">    export <code>LD_LIBRARY_PATH</code>=$<code>LD_LIBRARY_PATH</code>:path/to/your/libs
    </pre></div>
</li><li> <code>INCLUDE</code> environment variable should contain the list of paths 
where to find the header files of libraries
    <div class="example">
<pre class="example">    export <code>INCLUDE</code>=$<code>INCLUDE</code>:path/to/your/headers
    </pre></div>
</li></ul>

</li><li> detection with user&rsquo;s given paths:
  <ul>
<li> you can specify the path at cmake configure by invoking 
  <div class="example">
<pre class="example">  cmake &lt;path to SOURCE_DIR&gt; -DLIBNAME_DIR=path/to/your/lib 
  </pre></div>
<p>where LIB stands for the name of the lib to look for, example
  </p><div class="example">
<pre class="example">  cmake &lt;path to SOURCE_DIR&gt; -DSTARPU_DIR=path/to/starpudir \
                             -DCBLAS_DIR= ...
  </pre></div>
</li><li> it is also possible to specify headers and library directories 
separately, example
  <div class="example">
<pre class="example">  cmake &lt;path to SOURCE_DIR&gt;                           \
  -DSTARPU_INCDIR=path/to/libstarpu/include/starpu/1.1 \
  -DSTARPU_LIBDIR=path/to/libstarpu/lib
  </pre></div>
</li><li> Note BLAS and LAPACK detection can be tedious so that we provide a 
verbose mode. Use <samp>-DBLAS_VERBOSE=ON</samp> or <samp>-DLAPACK_VERBOSE=ON</samp> to 
enable it.
  </li></ul>
  
</li></ol>



<hr>
<a name="Use-FxT-profiling-through-StarPU"></a>
<div class="header">
<p>
Next: <a href="#Use-simulation-mode-with-StarPU_002dSimGrid" accesskey="n" rel="next">Use simulation mode with StarPU-SimGrid</a>, Previous: <a href="#Dependencies-detection" accesskey="p" rel="prev">Dependencies detection</a>, Up: <a href="#Configuring-CHAMELEON" accesskey="u" rel="up">Configuring CHAMELEON</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Use-FxT-profiling-through-StarPU-1"></a>
<h3 class="section">3.3 Use FxT profiling through StarPU</h3>

<p>StarPU can generate its own trace log files by compiling it with the 
<samp>--with-fxt</samp> 
option at the configure step (you can have to specify the directory where you 
installed FxT by giving <samp>--with-fxt=...</samp> instead of <samp>--with-fxt</samp> 
alone). 
By doing so, traces are generated after each execution of a program which uses 
StarPU in the directory pointed by the <code>STARPU_FXT_PREFIX</code> environment 
variable. Example: 
</p><div class="example">
<pre class="example">export <code>STARPU_FXT_PREFIX</code>=/home/yourname/fxt_files/
</pre></div>

<p>When executing a <code>./timing/...</code> CHAMELEON program, if it has been 
enabled (StarPU compiled with FxT and <samp>-DCHAMELEON_USE_FXT=ON</samp>), you 
can give the option <samp>--trace</samp> to tell the program to generate trace log 
files.
</p>
<p>Finally, to generate the trace file which can be opened with 
<a href="http://vite.gforge.inria.fr/">Vite</a> program, you have to use the 
<code>starpu_fxt_tool</code> executable of StarPU. 
This tool should be in <samp>path/to/your/install/starpu/bin</samp>. 
You can use it to generate the trace file like this: 
</p><ul>
<li> <code>path/to/your/install/starpu/bin/starpu_fxt_tool -i prof_filename</code>

<p>There is one file per mpi processus (prof_filename_0, prof_filename_1 ...).
To generate a trace of mpi programs you can call it like this:
</p></li><li> <code>path/to/your/install/starpu/bin/starpu_fxt_tool -i 
prof_filename*</code>

<p>The trace file will be named paje.trace (use -o option to specify an output 
name).
</p></li></ul>


<hr>
<a name="Use-simulation-mode-with-StarPU_002dSimGrid"></a>
<div class="header">
<p>
Previous: <a href="#Use-FxT-profiling-through-StarPU" accesskey="p" rel="prev">Use FxT profiling through StarPU</a>, Up: <a href="#Configuring-CHAMELEON" accesskey="u" rel="up">Configuring CHAMELEON</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Use-simulation-mode-with-StarPU_002dSimGrid-1"></a>
<h3 class="section">3.4 Use simulation mode with StarPU-SimGrid</h3>

<p>Simulation mode can be enabled by setting the cmake option 
<samp>-DCHAMELEON_SIMULATION=ON</samp>.
This mode allows you to simulate execution of algorithms with StarPU compiled 
with <a href="http://simgrid.gforge.inria.fr/">SimGrid</a>.
To do so, we provide some perfmodels in the <samp>simucore/perfmodels/</samp> 
directory of CHAMELEON sources.
To use these perfmodels, please set the following
</p><ul>
<li> <code>STARPU_HOME</code> environment variable to:
  <div class="example">
<pre class="example">  <code>&lt;path to SOURCE_DIR&gt;/simucore/perfmodels</code>
  </pre></div>
</li><li> <code>STARPU_HOSTNAME</code> environment variable to the name of the machine to 
simulate. For example, on our platform (PlaFRIM) with GPUs at Inria Bordeaux
  <div class="example">
<pre class="example">  <code>STARPU_HOSTNAME</code>=mirage
  </pre></div>
<p>Note that only POTRF kernels with block sizes of 320 or 960 (simple and double 
precision) on mirage machine are available for now.
Database of models is subject to change, it should be enrich in a near future.
</p></li></ul>


<hr>
<a name="Using-CHAMELEON"></a>
<div class="header">
<p>
Previous: <a href="#Configuring-CHAMELEON" accesskey="p" rel="prev">Configuring CHAMELEON</a>, Up: <a href="#Top" accesskey="u" rel="up">Top</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Using-CHAMELEON-1"></a>
<h2 class="chapter">4 Using CHAMELEON</h2>


<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Using-CHAMELEON-executables" accesskey="1">Using CHAMELEON executables</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Linking-an-external-application-with-CHAMELEON-libraries" accesskey="2">Linking an external application with CHAMELEON libraries</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#CHAMELEON-API" accesskey="3">CHAMELEON API</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Using-CHAMELEON-executables"></a>
<div class="header">
<p>
Next: <a href="#Linking-an-external-application-with-CHAMELEON-libraries" accesskey="n" rel="next">Linking an external application with CHAMELEON libraries</a>, Up: <a href="#Using-CHAMELEON" accesskey="u" rel="up">Using CHAMELEON</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Using-CHAMELEON-executables-1"></a>
<h3 class="section">4.1 Using CHAMELEON executables</h3>

<p>CHAMELEON provides several test executables that are compiled and link with 
CHAMELEON stack of dependencies.
Instructions about the arguments to give to executables are accessible thanks 
to the option <samp>-[-]help</samp> or <samp>-[-]h</samp>.
This set of binaries are separated into three categories and can be found in 
three different directories:
</p>
<ul>
<li> example

<p>contains examples of API usage and more specifically the 
  sub-directory lapack_to_morse/ provides a tutorial that explain how to use 
  CHAMELEON functionalities starting from a full LAPACK code, see 
<a href="#Tutorial-LAPACK-to-CHAMELEON">Tutorial LAPACK to CHAMELEON</a>
</p>
</li><li> testing

<p>contains testing drivers to check numerical correctness of 
  CHAMELEON linear algebra routines with a wide range of parameters
  </p><div class="example">
<pre class="example">  ./testing/stesting 4 1 LANGE 600 100 700
  </pre></div>
<p>Two first arguments are the number of cores and gpus to use.
  The third one is the name of the algorithm to test.
  The other arguments depend on the algorithm, here it lies for the number of 
  rows, columns and leading dimension of the problem.
</p>  
<p>Name of algorithms available for testing are:
  </p><ul>
<li> LANGE: norms of matrices Infinite, One, Max, Frobenius
    </li><li> GEMM: general matrix-matrix multiply
    </li><li> HEMM: hermitian matrix-matrix multiply
    </li><li> HERK: hermitian matrix-matrix rank k update
    </li><li> HER2K: hermitian matrix-matrix rank 2k update
    </li><li> SYMM: symmetric matrix-matrix multiply
    </li><li> SYRK: symmetric matrix-matrix rank k update
    </li><li> SYR2K: symmetric matrix-matrix rank 2k update
    </li><li> PEMV: matrix-vector multiply with pentadiagonal matrix    
    </li><li> TRMM: triangular matrix-matrix multiply
    </li><li> TRSM: triangular solve, multiple rhs
    </li><li> POSV: solve linear systems with symmetric positive-definite matrix
    </li><li> GESV_INCPIV: solve linear systems with general matrix    
    </li><li> GELS: linear least squares with general matrix
  </li></ul>

</li><li> timing

<p>contains timing drivers to assess performances of CHAMELEON routines.
  There are two sets of executables, those who do not use the tile interface 
and those who do (with _tile in the name of the executable).
  Executables without tile interface allocates data following LAPACK 
conventions and these data can be given as arguments to CHAMELEON routines 
as you would do with LAPACK.
  Executables with tile interface generate directly the data in the format 
  CHAMELEON tile algorithms used to submit tasks to the runtime system.
  Executables with tile interface should be more performant because no data 
copy from LAPACK matrix layout to tile matrix layout are necessary.
  Calling example:
  </p><div class="example">
<pre class="example">  ./timing/time_dpotrf --n_range=1000:10000:1000 --nb=320 
                       --threads=9 --gpus=3 
                       --nowarmup
  </pre></div>
  
<p>List of main options that can be used in timing:
  </p><ul>
<li> <samp>--help</samp>: show usage
    </li><li> <samp>--threads</samp>: Number of CPU workers (default: 
<samp>_SC_NPROCESSORS_ONLN</samp>)
    </li><li> <samp>--gpus</samp>: number of GPU workers (default: <samp>0</samp>)
    </li><li> <samp>--n_range=R</samp>: range of N values, with 
<samp>R=Start:Stop:Step</samp>
(default: <samp>500:5000:500</samp>)
    </li><li> <samp>--m=X</samp>: dimension (M) of the matrices (default: <samp>N</samp>)
    </li><li> <samp>--k=X</samp>: dimension (K) of the matrices (default: <samp>1</samp>), 
useful for GEMM algorithm (k is the shared dimension and must be defined &gt;1 to 
consider matrices and not vectors)
    </li><li> <samp>--nrhs=X</samp>: number of right-hand size (default: <samp>1</samp>)
    </li><li> <samp>--nb=X</samp>: block/tile size. (default: <samp>128</samp>)
    </li><li> <samp>--ib=X</samp>: inner-blocking/IB size. (default: <samp>32</samp>)
    </li><li> <samp>--niter=X</samp>: number of iterations performed for each test 
(default: <samp>1</samp>)
    </li><li> <samp>--rhblk=X</samp>: if X &gt; 0, enable Householder mode for QR and LQ 
factorization. X is the size of each subdomain (default: <samp>0</samp>)
    </li><li> <samp>--[no]check</samp>: check result (default: <samp>nocheck</samp>)
    </li><li> <samp>--[no]profile</samp>: print profiling informations (default: 
<samp>noprofile</samp>)
    </li><li> <samp>--[no]trace</samp>: enable/disable trace generation (default: 
<samp>notrace</samp>)
    </li><li> <samp>--[no]dag</samp>: enable/disable DAG generation (default: 
<samp>nodag</samp>)
    </li><li> <samp>--[no]inv</samp>: check on inverse (default: <samp>noinv</samp>)
    </li><li> <samp>--nocpu</samp>: all GPU kernels are exclusively executed on GPUs 
(default: <samp>0</samp>)
  </li></ul>
  
<p>List of timing algorithms available:
  </p><ul>
<li> LANGE: norms of matrices
    </li><li> GEMM: general matrix-matrix multiply
    </li><li> TRSM: triangular solve    
    </li><li> POTRF: Cholesky factorization with a symmetric 
positive-definite matrix
    </li><li> POSV: solve linear systems with symmetric positive-definite matrix
    </li><li> GETRF_NOPIV: LU factorization of a general matrix
using the tile LU algorithm without row pivoting 
    </li><li> GESV_NOPIV: solve linear system for a general matrix
using the tile LU algorithm without row pivoting 
    </li><li> GETRF_INCPIV: LU factorization of a general matrix
using the tile LU algorithm with partial tile pivoting with row interchanges 
    </li><li> GESV_INCPIV: solve linear system for a general matrix
using the tile LU algorithm with partial tile pivoting with row interchanges
matrix
    </li><li> GEQRF: QR factorization of a general matrix
    </li><li> GELS: solves overdetermined or underdetermined linear systems 
involving a general matrix using the QR or the LQ factorization
  </li></ul>
  
</li></ul>

<hr>
<a name="Linking-an-external-application-with-CHAMELEON-libraries"></a>
<div class="header">
<p>
Next: <a href="#CHAMELEON-API" accesskey="n" rel="next">CHAMELEON API</a>, Previous: <a href="#Using-CHAMELEON-executables" accesskey="p" rel="prev">Using CHAMELEON executables</a>, Up: <a href="#Using-CHAMELEON" accesskey="u" rel="up">Using CHAMELEON</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Linking-an-external-application-with-CHAMELEON-libraries-1"></a>
<h3 class="section">4.2 Linking an external application with CHAMELEON libraries</h3>

<p>Compilation and link with CHAMELEON libraries have been tested with 
<strong>gcc/gfortran 4.8.1</strong> and <strong>icc/ifort 14.0.2</strong>.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Static-linking-in-C" accesskey="1">Static linking in C</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Dynamic-linking-in-C" accesskey="2">Dynamic linking in C</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Build-a-Fortran-program-with-CHAMELEON" accesskey="3">Build a Fortran program with CHAMELEON</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Static-linking-in-C"></a>
<div class="header">
<p>
Next: <a href="#Dynamic-linking-in-C" accesskey="n" rel="next">Dynamic linking in C</a>, Up: <a href="#Linking-an-external-application-with-CHAMELEON-libraries" accesskey="u" rel="up">Linking an external application with CHAMELEON libraries</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Static-linking-in-C-1"></a>
<h4 class="subsection">4.2.1 Static linking in C</h4>

<p>Lets imagine you have a file main.c that you want to link with CHAMELEON 
static libraries.
Lets consider <samp>/home/yourname/install/chameleon</samp> is the install directory 
of CHAMELEON containing sub-directories <samp>include/</samp> and <samp>lib/</samp>.
Here could be your compilation command with gcc compiler:
</p><div class="example">
<pre class="example">gcc -I/home/yourname/install/chameleon/include -o main.o -c main.c
</pre></div>

<p>Now if you want to link your application with CHAMELEON static libraries, you 
could do:
</p><div class="example">
<pre class="example">gcc main.o -o main                                         \
/home/yourname/install/chameleon/lib/libchameleon.a        \
/home/yourname/install/chameleon/lib/libchameleon_starpu.a \
/home/yourname/install/chameleon/lib/libcoreblas.a         \
-lstarpu-1.1 -Wl,--no-as-needed -lmkl_intel_lp64           \
-lmkl_sequential -lmkl_core -lpthread -lm -lrt
</pre></div>
<p>As you can see in this example, we also link with some dynamic libraries 
<samp>starpu-1.1</samp>, <samp>Intel MKL</samp> libraries (for 
BLAS/LAPACK/CBLAS/LAPACKE), <samp>pthread</samp>, <samp>m</samp> (math) and 
<samp>rt</samp>.
These libraries will depend on the configuration of your CHAMELEON build.
You can find these dependencies in .pc files we generate during compilation and 
that are installed in the sub-directory <samp>lib/pkgconfig</samp> of your 
CHAMELEON install directory.
Note also that you could need to specify where to find these libraries with 
<samp>-L</samp> option of your compiler/linker.
</p>
<p>Before to run your program, make sure that all shared libraries paths your 
executable depends on are known.
Enter <code>ldd main</code> to check.
If some shared libraries paths are missing append them in the 
<code>LD_LIBRARY_PATH</code> (for Linux systems) environment variable 
(<code>DYLD_LIBRARY_PATH</code> on Mac, <code>LIB</code> on Windows).
</p>
<hr>
<a name="Dynamic-linking-in-C"></a>
<div class="header">
<p>
Next: <a href="#Build-a-Fortran-program-with-CHAMELEON" accesskey="n" rel="next">Build a Fortran program with CHAMELEON</a>, Previous: <a href="#Static-linking-in-C" accesskey="p" rel="prev">Static linking in C</a>, Up: <a href="#Linking-an-external-application-with-CHAMELEON-libraries" accesskey="u" rel="up">Linking an external application with CHAMELEON libraries</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Dynamic-linking-in-C-1"></a>
<h4 class="subsection">4.2.2 Dynamic linking in C</h4>

<p>For dynamic linking (need to build CHAMELEON with CMake 
option <samp>BUILD_SHARED_LIBS=ON</samp>) it is similar to static compilation/link 
but instead of specifying path to your static libraries you indicate the path 
to dynamic libraries with <samp>-L</samp> option and you give the name of libraries 
with <samp>-l</samp> option like this:
</p><div class="example">
<pre class="example">gcc main.o -o main                               \
-L/home/yourname/install/chameleon/lib           \
-lchameleon -lchameleon_starpu -lcoreblas        \
-lstarpu-1.1 -Wl,--no-as-needed -lmkl_intel_lp64 \
-lmkl_sequential -lmkl_core -lpthread -lm -lrt
</pre></div>

<p>Note that an update of your environment variable 
<code>LD_LIBRARY_PATH</code> (<code>DYLD_LIBRARY_PATH</code> on Mac, <code>LIB</code> on Windows) 
with the path of the libraries could be required before executing, example:
</p><div class="example">
<pre class="example">export <code>LD_LIBRARY_PATH</code>=path/to/libs:path/to/chameleon/lib 
</pre></div>

<hr>
<a name="Build-a-Fortran-program-with-CHAMELEON"></a>
<div class="header">
<p>
Previous: <a href="#Dynamic-linking-in-C" accesskey="p" rel="prev">Dynamic linking in C</a>, Up: <a href="#Linking-an-external-application-with-CHAMELEON-libraries" accesskey="u" rel="up">Linking an external application with CHAMELEON libraries</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Build-a-Fortran-program-with-CHAMELEON-1"></a>
<h4 class="subsection">4.2.3 Build a Fortran program with CHAMELEON</h4>

<p>CHAMELEON provides a Fortran interface to user functions. Example:
</p><div class="example">
<pre class="example">call morse_version(major, minor, patch) !or
call MORSE_VERSION(major, minor, patch)
</pre></div>

<p>Build and link are very similar to the C case.
</p>
<p>Compilation example:
</p><div class="example">
<pre class="example">gfortran -o main.o -c main.c
</pre></div>

<p>Static linking example:
</p><div class="example">
<pre class="example">gfortran main.o -o main                                    \
/home/yourname/install/chameleon/lib/libchameleon.a        \
/home/yourname/install/chameleon/lib/libchameleon_starpu.a \
/home/yourname/install/chameleon/lib/libcoreblas.a         \
-lstarpu-1.1 -Wl,--no-as-needed -lmkl_intel_lp64           \
-lmkl_sequential -lmkl_core -lpthread -lm -lrt
</pre></div>

<p>Dynamic linking example:
</p><div class="example">
<pre class="example">gfortran main.o -o main                          \
-L/home/yourname/install/chameleon/lib           \
-lchameleon -lchameleon_starpu -lcoreblas        \
-lstarpu-1.1 -Wl,--no-as-needed -lmkl_intel_lp64 \
-lmkl_sequential -lmkl_core -lpthread -lm -lrt
</pre></div>

<hr>
<a name="CHAMELEON-API"></a>
<div class="header">
<p>
Previous: <a href="#Linking-an-external-application-with-CHAMELEON-libraries" accesskey="p" rel="prev">Linking an external application with CHAMELEON libraries</a>, Up: <a href="#Using-CHAMELEON" accesskey="u" rel="up">Using CHAMELEON</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="CHAMELEON-API-1"></a>
<h3 class="section">4.3 CHAMELEON API</h3>

<p>CHAMELEON provides routines to solve dense general systems of linear 
equations, symmetric positive definite systems of linear equations and linear 
least squares problems, using LU, Cholesky, QR and LQ factorizations.
Real arithmetic and complex arithmetic are supported in both single precision 
and double precision.
Routines that compute linear algebra are of the folowing form:
</p><div class="example">
<pre class="example">MORSE_name[_Tile[_Async]]
</pre></div>
<ul>
<li> all user routines are prefixed with <code>MORSE</code>
</li><li> <code>name</code> follows BLAS/LAPACK naming scheme for algorithms 
(<em>e.g.</em> sgemm for general matrix-matrix multiply simple precision)
</li><li> CHAMELEON provides three interface levels
  <ul class="no-bullet">
<li>- <code>MORSE_name</code>: simplest interface, very close to CBLAS and LAPACKE, 
matrices are given following the LAPACK data layout (1-D array column-major). 
It involves copy of data from LAPACK layout to tile layout and conversely (to 
update LAPACK data), see <a href="#Step1">Step1</a>.
  </li><li>- <code>MORSE_name_Tile</code>: the tile interface avoid copies between LAPACK 
and tile layouts. It is the standard interface of CHAMELEON and it should 
achieved better performance than the previous simplest interface. The data are 
given through a specific structure called a descriptor, see <a href="#Step2">Step2</a>.
  </li><li>- <code>MORSE_name_Tile_Async</code>: similar to the tile interface, it avoids 
synchonization barrier normally called between <code>Tile</code> routines. 
At the end of an <code>Async</code> function, completion of tasks is not guarentee 
and data are not necessarily up-to-date. 
To ensure that tasks have been all executed a synchronization function has to 
be called after the sequence of <code>Async</code> functions, see <a href="#Step4">Step4</a>.
  </li></ul>
</li></ul>

<p>MORSE routine calls have to be precede from 
</p><div class="example">
<pre class="example">MORSE_Init( NCPU, NGPU );
</pre></div>
<p>to initialize MORSE and the runtime system and followed by
</p><div class="example">
<pre class="example">MORSE_Finalize();
</pre></div>
<p>to free some data and finalize the runtime and/or MPI.
</p>
<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Tutorial-LAPACK-to-CHAMELEON" accesskey="1">Tutorial LAPACK to CHAMELEON</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#List-of-available-routines" accesskey="2">List of available routines</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">
</td></tr>
</table>

<hr>
<a name="Tutorial-LAPACK-to-CHAMELEON"></a>
<div class="header">
<p>
Next: <a href="#List-of-available-routines" accesskey="n" rel="next">List of available routines</a>, Up: <a href="#CHAMELEON-API" accesskey="u" rel="up">CHAMELEON API</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Tutorial-LAPACK-to-CHAMELEON-1"></a>
<h4 class="subsection">4.3.1 Tutorial LAPACK to CHAMELEON</h4>

<p>This tutorial is dedicated to the API usage of CHAMELEON.
The idea is to start from a simple code and step by step explain how to 
use CHAMELEON routines. 
The first step is a full BLAS/LAPACK code without dependencies to CHAMELEON, 
a code that most users should easily understand.
Then, the different interfaces CHAMELEON provides are exposed, from the 
simplest API (step1) to more complicated ones (until step4).
The way some important parameters are set is discussed in step5.
Finally step6 is an example about distributed computation with MPI.
</p>
<p>Source files can be found in the <samp>example/lapack_to_morse/</samp> 
directory.
If CMake option <samp>CHAMELEON_ENABLE_EXAMPLE</samp> is <samp>ON</samp> then source 
files are compiled with the project libraries.
The arithmetic precision is <code>double</code>.
To execute a step &lsquo;<samp>X</samp>&rsquo;, enter the following command:
</p><div class="example">
<pre class="example">./step&lsquo;<samp>X</samp>&rsquo; --option1 --option2 ...
</pre></div>
<p>Instructions about the arguments to give to executables are accessible thanks 
to the option <samp>-[-]help</samp> or <samp>-[-]h</samp>.
Note there exist default values for options.
</p>
<p>For all steps, the program solves a linear system <em>Ax=B</em>
The matrix values are randomly generated but ensure that matrix <em>A</em> is 
symmetric positive definite so that <em>A</em> can be factorized in a <em>LL^T</em> 
form using the Cholesky factorization.
</p>

<p>Lets comment the different steps of the tutorial
</p><table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Step0" accesskey="1">Step0</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">a simple Cholesky example using the C interface of 
BLAS/LAPACK
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Step1" accesskey="2">Step1</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">introduces the LAPACK equivalent interface of MORSE
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Step2" accesskey="3">Step2</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">introduces the tile interface
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Step3" accesskey="4">Step3</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">indicates how to give your own tile matrix to MORSE
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Step4" accesskey="5">Step4</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">introduces the tile async interface
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Step5" accesskey="6">Step5</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">shows how to set some important parameters
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Step6" accesskey="7">Step6</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">introduces how to benefit from MPI in MORSE.
</td></tr>
</table>

<hr>
<a name="Step0"></a>
<div class="header">
<p>
Next: <a href="#Step1" accesskey="n" rel="next">Step1</a>, Up: <a href="#Tutorial-LAPACK-to-CHAMELEON" accesskey="u" rel="up">Tutorial LAPACK to CHAMELEON</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Step0-1"></a>
<h4 class="subsubsection">4.3.1.1 Step0</h4>

<p>The C interface of BLAS and LAPACK, that is, CBLAS and 
LAPACKE, are used to solve the system. The size of the system (matrix) and the 
number of right hand-sides can be given as arguments to the executable (be 
careful not to give huge numbers if you do not have an infinite amount of RAM!).
As for every step, the correctness of the solution is checked by calculating 
the norm <em>||Ax-B||/(||A||||x||+||B||)</em>.
The time spent in factorization+solve is recorded and, because we know exactly 
the number of operations of these algorithms, we deduce the number of 
operations that have been processed per second (in GFlops/s).
The important part of the code that solves the problem is:
</p><pre class="verbatim">/* Cholesky factorization:
 * A is replaced by its factorization L or L^T depending on uplo */
LAPACKE_dpotrf( LAPACK_COL_MAJOR, 'U', N, A, N );
/* Solve:
 * B is stored in X on entry, X contains the result on exit.
 * Forward ...
 */
cblas_dtrsm(
    CblasColMajor,
    CblasLeft,
    CblasUpper,
    CblasConjTrans,
    CblasNonUnit,
    N, NRHS, 1.0, A, N, X, N);
/* ... and back substitution */
cblas_dtrsm(
    CblasColMajor,
    CblasLeft,
    CblasUpper,
    CblasNoTrans,
    CblasNonUnit,
    N, NRHS, 1.0, A, N, X, N);
</pre>
<hr>
<a name="Step1"></a>
<div class="header">
<p>
Next: <a href="#Step2" accesskey="n" rel="next">Step2</a>, Previous: <a href="#Step0" accesskey="p" rel="prev">Step0</a>, Up: <a href="#Tutorial-LAPACK-to-CHAMELEON" accesskey="u" rel="up">Tutorial LAPACK to CHAMELEON</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Step1-1"></a>
<h4 class="subsubsection">4.3.1.2 Step1</h4>

<p>It introduces the simplest CHAMELEON interface which is equivalent to 
CBLAS/LAPACKE.
The code is very similar to step0 but instead of calling CBLAS/LAPACKE 
functions, we call CHAMELEON equivalent functions. 
The solving code becomes:
</p><pre class="verbatim">/* Factorization: */
MORSE_dpotrf( UPLO, N, A, N );
/* Solve: */
MORSE_dpotrs(UPLO, N, NRHS, A, N, X, N);
</pre><p>The API is almost the same so that it is easy to use for beginners.
It is important to keep in mind that before any call to MORSE routines, 
<code>MORSE_Init</code> has to be invoked to initialize MORSE and the runtime system.
Example:
</p><pre class="verbatim">MORSE_Init( NCPU, NGPU );
</pre><p>After all MORSE calls have been done, a call to <code>MORSE_Finalize</code> is 
required to free some data and finalize the runtime and/or MPI.
</p><pre class="verbatim">MORSE_Finalize();
</pre><p>We use MORSE routines with the LAPACK interface which means the routines 
accepts the same matrix format as LAPACK (1-D array column-major).
Note that we copy the matrix to get it in our own tile structures, see details 
about this format here <a href="#Tile-Data-Layout">Tile Data Layout</a>. 
This means you can get an overhead coming from copies.
</p>
<hr>
<a name="Step2"></a>
<div class="header">
<p>
Next: <a href="#Step3" accesskey="n" rel="next">Step3</a>, Previous: <a href="#Step1" accesskey="p" rel="prev">Step1</a>, Up: <a href="#Tutorial-LAPACK-to-CHAMELEON" accesskey="u" rel="up">Tutorial LAPACK to CHAMELEON</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Step2-1"></a>
<h4 class="subsubsection">4.3.1.3 Step2</h4>

<p>This program is a copy of step1 but instead of using the LAPACK interface which 
leads to copy LAPACK matrices inside MORSE routines we use the tile interface.
We will still use standard format of matrix but we will see how to give this
matrix to create a MORSE descriptor, a structure wrapping data on which we want 
to apply sequential task-based algorithms.
The solving code becomes:
</p><pre class="verbatim">/* Factorization: */
MORSE_dpotrf_Tile( UPLO, descA );
/* Solve: */
MORSE_dpotrs_Tile( UPLO, descA, descX );
</pre><p>To use the tile interface, a specific structure <code>MORSE_desc_t</code> must be 
created.
This can be achieved from different ways.
</p><ol>
<li> Use the existing function <code>MORSE_Desc_Create</code>: means the 
matrix data are considered contiguous in memory as it is considered in PLASMA 
(<a href="#Tile-Data-Layout">Tile Data Layout</a>).
</li><li> Use the existing function <code>MORSE_Desc_Create_User</code>: it is more 
flexible than <code>Desc_Create</code> because you can give your own way to access to 
tile data so that your tiles can be allocated wherever you want in memory, see 
next paragraph <a href="#Step3">Step3</a>.
</li><li> Create you own function to fill the descriptor. 
If you understand well the meaning of each item of <code>MORSE_desc_t</code>, you 
should be able to fill correctly the structure (good luck).
</li></ol>

<p>In Step2, we use the first way to create the descriptor:
</p><pre class="verbatim">MORSE_Desc_Create(&amp;descA, NULL, MorseRealDouble,
                  NB, NB, NB*NB, N, N, 
                  0, 0, N, N, 
                  1, 1);
</pre>
<ul>
<li> <code>descA</code> is the descriptor to create.

</li><li> The second argument is a pointer to existing data.
The existing data must follow LAPACK/PLASMA matrix layout <a href="#Tile-Data-Layout">Tile Data Layout</a> (1-D array column-major) if <code>MORSE_Desc_Create</code> is used to create 
the descriptor.
The <code>MORSE_Desc_Create_User</code> function can be used if you have data 
organized differently. 
This is discussed in the next paragraph <a href="#Step3">Step3</a>. 
Giving a <code>NULL</code> pointer means you let the function allocate memory space.
This requires to copy your data in the memory allocated by the 
<code>Desc_Create</code>.
This can be done with
<pre class="verbatim">MORSE_Lapack_to_Tile(A, N, descA);
</pre>
</li><li> Third argument of <code>Desc_Create</code> is the datatype (used for memory 
allocation).

</li><li> Fourth argument until sixth argument stand for respectively, the number 
of rows (<code>NB</code>), columns (<code>NB</code>) in each tile, the total number of 
values in a tile (<code>NB*NB</code>), the number of rows (<code>N</code>), colmumns 
(<code>N</code>) in the entire matrix.

</li><li> Seventh argument until ninth argument stand for respectively, the 
beginning row (<code>0</code>), column (<code>0</code>) indexes of the submatrix and the 
number of rows (<code>N</code>), columns (<code>N</code>) in the submatrix.
These arguments are specific and used in precise cases.
If you do not consider submatrices, just use <code>0, 0, NROWS, NCOLS</code>.

</li><li> Two last arguments are the parameter of the 2-D block-cyclic distribution 
grid, see <a href="http://www.netlib.org/scalapack/slug/node75.html">ScaLAPACK</a>.
To be able to use other data distribution over the nodes, 
<code>MORSE_Desc_Create_User</code> function should be used.

</li></ul>


<hr>
<a name="Step3"></a>
<div class="header">
<p>
Next: <a href="#Step4" accesskey="n" rel="next">Step4</a>, Previous: <a href="#Step2" accesskey="p" rel="prev">Step2</a>, Up: <a href="#Tutorial-LAPACK-to-CHAMELEON" accesskey="u" rel="up">Tutorial LAPACK to CHAMELEON</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Step3-1"></a>
<h4 class="subsubsection">4.3.1.4 Step3</h4>

<p>This program makes use of the same interface than Step2 (tile interface) but 
does not allocate LAPACK matrices anymore so that no copy between LAPACK matrix 
layout and tile matrix layout are necessary to call MORSE routines.
To generate random right hand-sides you can use:
</p><pre class="verbatim">/* Allocate memory and initialize descriptor B */
MORSE_Desc_Create(&amp;descB,  NULL, MorseRealDouble,
                  NB, NB,  NB*NB, N, NRHS, 
                  0, 0, N, NRHS, 1, 1);
/* generate RHS with random values */
MORSE_dplrnt_Tile( descB, 5673 );
</pre>
<p>The other important point is that is it possible to create a descriptor, the 
necessary structure to call MORSE efficiently, by giving your own pointer to 
tiles if your matrix is not organized as a 1-D array column-major.
This can be achieved with the <code>MORSE_Desc_Create_User</code> routine.
Here is an example:
</p><pre class="verbatim">MORSE_Desc_Create_User(&amp;descA, matA, MorseRealDouble,
		       NB, NB, NB*NB, N, N, 
		       0, 0, N, N, 1, 1,
		       user_getaddr_arrayofpointers,
		       user_getblkldd_arrayofpointers,
		       user_getrankof_zero);
</pre><p>Firsts arguments are the same than <code>MORSE_Desc_Create</code> routine. 
Following arguments allows you to give pointer to functions that manage the
access to tiles from the structure given as second argument.
Here for example, <code>matA</code> is an array containing addresses to tiles, see 
the function <code>allocate_tile_matrix</code> defined in <samp>step3.h</samp>.
The three functions you have to define for <code>Desc_Create_User</code> are:
</p><ul>
<li> a function that returns address of tile <em>A(m,n)</em>, m and n standing 
for the indexes of the tile in the global matrix. Lets consider a matrix 
<em>4x4</em> with tile size <em>2x2</em>, the matrix contains four tiles of 
indexes: <em>A(m=0,n=0)</em>, <em>A(m=0,n=1)</em>, <em>A(m=1,n=0)</em>, 
<em>A(m=1,n=1)</em>
</li><li> a function that returns the leading dimension of tile <em>A(m,*)</em>
</li><li> a function that returns MPI rank of tile <em>A(m,n)</em>
</li></ul>
<p>Examples for these functions are vizible in <samp>step3.h</samp>.
Note that the way we define these functions is related to the tile matrix 
format and to the data distribution considered.
This example should not be used with MPI since all tiles are affected to 
processus <code>0</code>, which means a large amount of data will be 
potentially transfered between nodes.
</p>
<hr>
<a name="Step4"></a>
<div class="header">
<p>
Next: <a href="#Step5" accesskey="n" rel="next">Step5</a>, Previous: <a href="#Step3" accesskey="p" rel="prev">Step3</a>, Up: <a href="#Tutorial-LAPACK-to-CHAMELEON" accesskey="u" rel="up">Tutorial LAPACK to CHAMELEON</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Step4-1"></a>
<h4 class="subsubsection">4.3.1.5 Step4</h4>
<p>This program is a copy of step2 but instead of using the tile interface, it 
uses the tile async interface.
The goal is to exhibit the runtime synchronization barriers.
Keep in mind that when the tile interface is called, like 
<code>MORSE_dpotrf_Tile</code>, a synchronization function, waiting for the actual 
execution and termination of all tasks, is called to ensure the 
proper completion of the algorithm (i.e. data are up-to-date).
The code shows how to exploit the async interface to pipeline subsequent 
algorithms so that less synchronisations are done.
The code becomes:
</p><pre class="verbatim">/* Morse structure containing parameters and a structure to interact with
 * the Runtime system */
MORSE_context_t *morse;
/* MORSE sequence uniquely identifies a set of asynchronous function calls
 * sharing common exception handling */
MORSE_sequence_t *sequence = NULL;
/* MORSE request uniquely identifies each asynchronous function call */
MORSE_request_t request = MORSE_REQUEST_INITIALIZER;
int status;

...

morse_sequence_create(morse, &amp;sequence);

/* Factorization: */
MORSE_dpotrf_Tile_Async( UPLO, descA, sequence, &amp;request );

/* Solve: */
MORSE_dpotrs_Tile_Async( UPLO, descA, descX, sequence, &amp;request);

/* Synchronization barrier (the runtime ensures that all submitted tasks
 * have been terminated */
RUNTIME_barrier(morse);
/* Ensure that all data processed on the gpus we are depending on are back
 * in main memory */
RUNTIME_desc_getoncpu(descA);
RUNTIME_desc_getoncpu(descX);

status = sequence-&gt;status;
    
</pre><p>Here the sequence of <code>dpotrf</code> and <code>dpotrs</code> algorithms is processed 
without synchronization so that some tasks of <code>dpotrf</code> and <code>dpotrs</code> 
can be concurently executed which could increase performances.
The async interface is very similar to the tile one.
It is only necessary to give two new objects <code>MORSE_sequence_t</code> and 
<code>MORSE_request_t</code> used to handle asynchronous function calls.
</p>
<div align="center"><img src="potri_async.png" alt="potri_async">
</div><p>POTRI (POTRF, TRTRI, LAUUM) algorithm with and without synchronization 
barriers, courtesey of the <a href="http://icl.cs.utk.edu/plasma/">PLASMA</a> team.
</p>
<hr>
<a name="Step5"></a>
<div class="header">
<p>
Next: <a href="#Step6" accesskey="n" rel="next">Step6</a>, Previous: <a href="#Step4" accesskey="p" rel="prev">Step4</a>, Up: <a href="#Tutorial-LAPACK-to-CHAMELEON" accesskey="u" rel="up">Tutorial LAPACK to CHAMELEON</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Step5-1"></a>
<h4 class="subsubsection">4.3.1.6 Step5</h4>

<p>Step5 shows how to set some important parameters.
This program is a copy of Step4 but some additional parameters are given by 
the user. 
The parameters that can be set are:
</p><ul>
<li> number of Threads
</li><li> number of GPUs

<p>The number of workers can be given as argument to the executable with 
<samp>--threads=</samp> and <samp>--gpus=</samp> options.
It is important to notice that we assign one thread per gpu to optimize data 
transfer between main memory and devices memory.
The number of workers of each type <code>CPU</code> and <code>CUDA</code> must be given at 
<code>MORSE_Init</code>.
</p><pre class="verbatim">if ( iparam[IPARAM_THRDNBR] == -1 ) {
    get_thread_count( &amp;(iparam[IPARAM_THRDNBR]) );
    /* reserve one thread par cuda device to optimize memory transfers */
    iparam[IPARAM_THRDNBR] -= iparam[IPARAM_NCUDAS];
}
NCPU = iparam[IPARAM_THRDNBR];
NGPU = iparam[IPARAM_NCUDAS];

/* initialize MORSE with main parameters */
MORSE_Init( NCPU, NGPU );
</pre>
</li><li> matrix size
</li><li> number of right-hand sides
</li><li> block (tile) size

<p>The problem size is given with <samp>--n=</samp> and <samp>--nrhs=</samp> options.
The tile size is given with option <samp>--nb=</samp>.
These parameters are required to create descriptors.
The size tile <code>NB</code> is a key parameter to get performances since it 
defines the granularity of tasks.
If <code>NB</code> is too large compared to <code>N</code>, there are few tasks to 
schedule. 
If the number of workers is large this leads to limit parallelism.
On the contrary, if <code>NB</code> is too small (<em>i.e.</em> many small tasks), 
workers could not be correctly fed and the runtime systems operations 
could represent a substantial overhead.
A trade-off has to be found depending on many parameters: problem size, 
algorithm (drive data dependencies), architecture (number of workers, 
workers speed, workers uniformity, memory bus speed).
By default it is set to 128. 
Do not hesitate to play with this parameter and compare performances on your 
machine.
</p>
</li><li> inner-blocking size

<p>The inner-blocking size is given with option <samp>--ib=</samp>.
This parameter is used by kernels (optimized algorithms applied on tiles) to 
perform subsequent operations with data block-size that fits the cache of 
workers.
Parameters <code>NB</code> and <code>IB</code> can be given with <code>MORSE_Set</code> function:
</p><pre class="verbatim">MORSE_Set(MORSE_TILE_SIZE,        iparam[IPARAM_NB] );
MORSE_Set(MORSE_INNER_BLOCK_SIZE, iparam[IPARAM_IB] );
</pre></li></ul>
 
<hr>
<a name="Step6"></a>
<div class="header">
<p>
Previous: <a href="#Step5" accesskey="p" rel="prev">Step5</a>, Up: <a href="#Tutorial-LAPACK-to-CHAMELEON" accesskey="u" rel="up">Tutorial LAPACK to CHAMELEON</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Step6-1"></a>
<h4 class="subsubsection">4.3.1.7 Step6</h4>

<p>This program is a copy of Step5 with some additional parameters to be set for 
the data distribution. 
To use this program properly MORSE must use StarPU Runtime system and MPI 
option must be activated at configure. 
The data distribution used here is 2-D block-cyclic, see for example
<a href="http://www.netlib.org/scalapack/slug/node75.html">ScaLAPACK</a> for 
explanation.
The user can enter the parameters of the distribution grid at execution with 
<samp>--p=</samp> option.
Example using OpenMPI on four nodes with one process per node:
</p><div class="example">
<pre class="example">mpirun -np 4 ./step6 --n=10000 --nb=320 --ib=64 \
                     --threads=8 --gpus=2 --p=2
</pre></div>

<p>In this program we use the tile data layout from PLASMA so that the call 
</p><pre class="verbatim">MORSE_Desc_Create_User(&amp;descA, NULL, MorseRealDouble,
		       NB, NB, NB*NB, N, N, 
		       0, 0, N, N,
		       GRID_P, GRID_Q,
		       morse_getaddr_ccrb,
		       morse_getblkldd_ccrb,
		       morse_getrankof_2d);
</pre><p>is equivalent to the following call
</p><pre class="verbatim">MORSE_Desc_Create(&amp;descA, NULL, MorseRealDouble,
                  NB, NB, NB*NB, N, N, 
                  0, 0, N, N, 
                  GRID_P, GRID_Q);
</pre><p>functions <code>morse_getaddr_ccrb</code>, <code>morse_getblkldd_ccrb</code>, 
<code>morse_getrankof_2d</code> being used in <code>Desc_Create</code>.
It is interesting to notice that the code is almost the same as Step5.
The only additional information to give is the way tiles are distributed 
through the third function given to <code>MORSE_Desc_Create_User</code>.
Here, because we have made experiments only with a 2-D block-cyclic 
distribution, we have parameters P and Q in the interface of <code>Desc_Create</code>
but they have sense only for 2-D block-cyclic distribution and then using 
<code>morse_getrankof_2d</code> function.
Of course it could be used with other distributions, being no more the 
parameters of a 2-D block-cyclic grid but of another distribution.
</p>
<hr>
<a name="List-of-available-routines"></a>
<div class="header">
<p>
Previous: <a href="#Tutorial-LAPACK-to-CHAMELEON" accesskey="p" rel="prev">Tutorial LAPACK to CHAMELEON</a>, Up: <a href="#CHAMELEON-API" accesskey="u" rel="up">CHAMELEON API</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="List-of-available-routines-1"></a>
<h4 class="subsection">4.3.2 List of available routines</h4>

<table class="menu" border="0" cellspacing="0">
<tr><td align="left" valign="top">&bull; <a href="#Auxiliary-routines" accesskey="1">Auxiliary routines</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Init, Finalize, Version, etc
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Descriptor-routines" accesskey="2">Descriptor routines</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">To handle descriptors
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Options-routines" accesskey="3">Options routines</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">To set options
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Sequences-routines" accesskey="4">Sequences routines</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">To manage asynchronous function calls 
</td></tr>
<tr><td align="left" valign="top">&bull; <a href="#Linear-Algebra-routines" accesskey="5">Linear Algebra routines</a>:</td><td>&nbsp;&nbsp;</td><td align="left" valign="top">Computional routines
</td></tr>
</table>

<hr>
<a name="Auxiliary-routines"></a>
<div class="header">
<p>
Next: <a href="#Descriptor-routines" accesskey="n" rel="next">Descriptor routines</a>, Up: <a href="#List-of-available-routines" accesskey="u" rel="up">List of available routines</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Auxiliary-routines-1"></a>
<h4 class="subsubsection">4.3.2.1 Auxiliary routines</h4>

<p>Reports MORSE version number.
</p><pre class="verbatim">int MORSE_Version        (int *ver_major, int *ver_minor, int *ver_micro);
</pre>
<p>Initialize MORSE: initialize some parameters, initialize the runtime and/or MPI.
</p><pre class="verbatim">int MORSE_Init           (int nworkers, int ncudas);
</pre>
<p>Finalyze MORSE: free some data and finalize the runtime and/or MPI.
</p><pre class="verbatim">int MORSE_Finalize       (void);
</pre>
<p>Return the MPI rank of the calling process.
</p><pre class="verbatim">int MORSE_My_Mpi_Rank    (void);
</pre>
<p>Suspend MORSE runtime to poll for new tasks, to avoid useless CPU consumption when 
no tasks have to be executed by MORSE runtime system.
</p><pre class="verbatim">int MORSE_Pause          (void);
</pre>
<p>Symmetrical call to MORSE_Pause, used to resume the workers polling for new tasks.
</p><pre class="verbatim">int MORSE_Resume         (void);
</pre>
<p>Conversion from LAPACK layout to tile layout.
</p><pre class="verbatim">int MORSE_Lapack_to_Tile (void *Af77, int LDA, MORSE_desc_t *A);
</pre>
<p>Conversion from tile layout to LAPACK layout.
</p><pre class="verbatim">int MORSE_Tile_to_Lapack (MORSE_desc_t *A, void *Af77, int LDA);
</pre>
<hr>
<a name="Descriptor-routines"></a>
<div class="header">
<p>
Next: <a href="#Options-routines" accesskey="n" rel="next">Options routines</a>, Previous: <a href="#Auxiliary-routines" accesskey="p" rel="prev">Auxiliary routines</a>, Up: <a href="#List-of-available-routines" accesskey="u" rel="up">List of available routines</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Descriptor-routines-1"></a>
<h4 class="subsubsection">4.3.2.2 Descriptor routines</h4>

<p>Create matrix descriptor, internal function.
</p><pre class="verbatim">int MORSE_Desc_Create  (MORSE_desc_t **desc, void *mat, MORSE_enum dtyp,
                        int mb, int nb, int bsiz, int lm, int ln,
                        int i, int j, int m, int n, int p, int q);
</pre>
<p>Create matrix descriptor, user function.
</p><pre class="verbatim">int MORSE_Desc_Create_User(MORSE_desc_t **desc, void *mat, MORSE_enum dtyp,
                           int mb, int nb, int bsiz, int lm, int ln,
                           int i, int j, int m, int n, int p, int q,
                           void* (*get_blkaddr)( const MORSE_desc_t*, int, int),
                           int (*get_blkldd)( const MORSE_desc_t*, int ),
                           int (*get_rankof)( const MORSE_desc_t*, int, int ));
</pre>
<p>Destroys matrix descriptor.
</p><pre class="verbatim">int MORSE_Desc_Destroy (MORSE_desc_t **desc);
</pre>
<p>Ensure that all data are up-to-date in main memory (even if some tasks have 
been processed on GPUs)
</p><pre class="verbatim">int MORSE_Desc_Getoncpu(MORSE_desc_t  *desc);
</pre>
<hr>
<a name="Options-routines"></a>
<div class="header">
<p>
Next: <a href="#Sequences-routines" accesskey="n" rel="next">Sequences routines</a>, Previous: <a href="#Descriptor-routines" accesskey="p" rel="prev">Descriptor routines</a>, Up: <a href="#List-of-available-routines" accesskey="u" rel="up">List of available routines</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Options-routines-1"></a>
<h4 class="subsubsection">4.3.2.3 Options routines</h4>

<p>Enable MORSE feature.
</p><pre class="verbatim">int MORSE_Enable  (MORSE_enum option);
</pre><p>Feature to be enabled:
</p><ul>
<li> <code>MORSE_WARNINGS</code>:   printing of warning messages,
</li><li> <code>MORSE_ERRORS</code>:     printing of error messages,
</li><li> <code>MORSE_AUTOTUNING</code>: autotuning for tile size and inner block size,
</li><li> <code>MORSE_PROFILING_MODE</code>:  activate kernels profiling.
</li></ul>

<p>Disable MORSE feature.
</p><pre class="verbatim">int MORSE_Disable (MORSE_enum option);
</pre><p>Symmetric to <code>MORSE_Enable</code>.
</p>
<p>Set MORSE parameter.
</p><pre class="verbatim">int MORSE_Set     (MORSE_enum param, int  value);
</pre><p>Parameters to be set:
</p><ul>
<li> <code>MORSE_TILE_SIZE</code>:        size matrix tile,
</li><li> <code>MORSE_INNER_BLOCK_SIZE</code>: size of tile inner block,
</li><li> <code>MORSE_HOUSEHOLDER_MODE</code>: type of householder trees (FLAT or TREE),
</li><li> <code>MORSE_HOUSEHOLDER_SIZE</code>: size of the groups in householder trees,
</li><li> <code>MORSE_TRANSLATION_MODE</code>: related to the 
<code>MORSE_Lapack_to_Tile</code>, see <samp>ztile.c</samp>.
</li></ul>

<p>Get value of MORSE parameter.
</p><pre class="verbatim">int MORSE_Get     (MORSE_enum param, int *value);
</pre>
<hr>
<a name="Sequences-routines"></a>
<div class="header">
<p>
Next: <a href="#Linear-Algebra-routines" accesskey="n" rel="next">Linear Algebra routines</a>, Previous: <a href="#Options-routines" accesskey="p" rel="prev">Options routines</a>, Up: <a href="#List-of-available-routines" accesskey="u" rel="up">List of available routines</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Sequences-routines-1"></a>
<h4 class="subsubsection">4.3.2.4 Sequences routines</h4>

<p>Create a sequence.
</p><pre class="verbatim">int MORSE_Sequence_Create  (MORSE_sequence_t **sequence);
</pre>
<p>Destroy a sequence.
</p><pre class="verbatim">int MORSE_Sequence_Destroy (MORSE_sequence_t *sequence);
</pre>
<p>Wait for the completion of a sequence.
</p><pre class="verbatim">int MORSE_Sequence_Wait    (MORSE_sequence_t *sequence);
</pre>
<hr>
<a name="Linear-Algebra-routines"></a>
<div class="header">
<p>
Previous: <a href="#Sequences-routines" accesskey="p" rel="prev">Sequences routines</a>, Up: <a href="#List-of-available-routines" accesskey="u" rel="up">List of available routines</a> &nbsp; [<a href="#SEC_Contents" title="Table of contents" rel="contents">Contents</a>]</p>
</div>
<a name="Linear-Algebra-routines-1"></a>
<h4 class="subsubsection">4.3.2.5 Linear Algebra routines</h4>

<p>Routines computing linear algebra of the form 
<code>MORSE_name[_Tile[_Async]]</code> (<code>name</code> follows LAPACK naming scheme, see 
<a href="http://www.netlib.org/lapack/lug/node24.html">http://www.netlib.org/lapack/lug/node24.html</a> availables:
</p>
<pre class="verbatim">/** ********************************************************
 *  Declarations of computational functions (LAPACK layout) 
 **/
 
int MORSE_zgelqf(int M, int N, MORSE_Complex64_t *A, int LDA, 
                 MORSE_desc_t *descT);
                 
int MORSE_zgelqs(int M, int N, int NRHS, MORSE_Complex64_t *A, int LDA, 
                 MORSE_desc_t *descT, MORSE_Complex64_t *B, int LDB);
                 
int MORSE_zgels(MORSE_enum trans, int M, int N, int NRHS, 
                MORSE_Complex64_t *A, int LDA, MORSE_desc_t *descT, 
                MORSE_Complex64_t *B, int LDB);

int MORSE_zgemm(MORSE_enum transA, MORSE_enum transB, int M, int N, int K, 
                MORSE_Complex64_t alpha, MORSE_Complex64_t *A, int LDA, 
                MORSE_Complex64_t *B, int LDB, MORSE_Complex64_t beta, 
                MORSE_Complex64_t *C, int LDC);

int MORSE_zgeqrf(int M, int N, MORSE_Complex64_t *A, int LDA, 
                 MORSE_desc_t *descT);
                 
int MORSE_zgeqrs(int M, int N, int NRHS, MORSE_Complex64_t *A, int LDA, 
                 MORSE_desc_t *descT, MORSE_Complex64_t *B, int LDB);

int MORSE_zgesv_incpiv(int N, int NRHS, MORSE_Complex64_t *A, int LDA, 
                       MORSE_desc_t *descL, int *IPIV, 
                       MORSE_Complex64_t *B, int LDB);

int MORSE_zgesv_nopiv(int N, int NRHS, MORSE_Complex64_t *A, int LDA, 
                      MORSE_Complex64_t *B, int LDB);

int MORSE_zgetrf_incpiv(int M, int N, MORSE_Complex64_t *A, int LDA, 
                        MORSE_desc_t *descL, int *IPIV);

int MORSE_zgetrf_nopiv(int M, int N, MORSE_Complex64_t *A, int LDA);

int MORSE_zgetrs_incpiv(MORSE_enum trans, int N, int NRHS, 
                        MORSE_Complex64_t *A, int LDA, 
                        MORSE_desc_t *descL, int *IPIV, 
                        MORSE_Complex64_t *B, int LDB);

int MORSE_zgetrs_nopiv(MORSE_enum trans, int N, int NRHS, 
                       MORSE_Complex64_t *A, int LDA, 
                       MORSE_Complex64_t *B, int LDB);

#ifdef COMPLEX
int MORSE_zhemm(MORSE_enum side, MORSE_enum uplo, int M, int N, 
                MORSE_Complex64_t alpha, MORSE_Complex64_t *A, int LDA, 
                MORSE_Complex64_t *B, int LDB, MORSE_Complex64_t beta, 
                MORSE_Complex64_t *C, int LDC);

int MORSE_zherk(MORSE_enum uplo, MORSE_enum trans, int N, int K, 
                double alpha, MORSE_Complex64_t *A, int LDA, 
                double beta, MORSE_Complex64_t *C, int LDC);

int MORSE_zher2k(MORSE_enum uplo, MORSE_enum trans, int N, int K, 
                 MORSE_Complex64_t alpha, MORSE_Complex64_t *A, int LDA, 
                 MORSE_Complex64_t *B, int LDB, double beta, 
                 MORSE_Complex64_t *C, int LDC);
#endif

int MORSE_zlacpy(MORSE_enum uplo, int M, int N, 
                 MORSE_Complex64_t *A, int LDA, 
                 MORSE_Complex64_t *B, int LDB);

double MORSE_zlange(MORSE_enum norm, int M, int N, 
                    MORSE_Complex64_t *A, int LDA);

#ifdef COMPLEX
double MORSE_zlanhe(MORSE_enum norm, MORSE_enum uplo, int N, 
                    MORSE_Complex64_t *A, int LDA);
#endif

double MORSE_zlansy(MORSE_enum norm, MORSE_enum uplo, int N, 
                    MORSE_Complex64_t *A, int LDA);

double MORSE_zlantr(MORSE_enum norm, MORSE_enum uplo, MORSE_enum diag, 
                    int M, int N, MORSE_Complex64_t *A, int LDA);

int MORSE_zlaset(MORSE_enum uplo, int M, int N, MORSE_Complex64_t alpha, 
                 MORSE_Complex64_t beta, MORSE_Complex64_t *A, int LDA);

int MORSE_zlauum(MORSE_enum uplo, int N, MORSE_Complex64_t *A, int LDA);

#ifdef COMPLEX
int MORSE_zplghe( double bump, int N, MORSE_Complex64_t *A, int LDA, 
                  unsigned long long int seed );
#endif

int MORSE_zplgsy( MORSE_Complex64_t bump, int N, 
                  MORSE_Complex64_t *A, int LDA, 
                  unsigned long long int seed );

int MORSE_zplrnt( int M, int N, MORSE_Complex64_t *A, int LDA, 
                  unsigned long long int seed );

int MORSE_zposv(MORSE_enum uplo, int N, int NRHS, 
                MORSE_Complex64_t *A, int LDA, 
                MORSE_Complex64_t *B, int LDB);

int MORSE_zpotrf(MORSE_enum uplo, int N, MORSE_Complex64_t *A, int LDA);

int MORSE_zsytrf(MORSE_enum uplo, int N, MORSE_Complex64_t *A, int LDA);

int MORSE_zpotri(MORSE_enum uplo, int N, MORSE_Complex64_t *A, int LDA);

int MORSE_zpotrs(MORSE_enum uplo, int N, int NRHS, 
                 MORSE_Complex64_t *A, int LDA, 
                 MORSE_Complex64_t *B, int LDB);

#if defined (PRECISION_c) || defined(PRECISION_z)
int MORSE_zsytrs(MORSE_enum uplo, int N, int NRHS, 
                 MORSE_Complex64_t *A, int LDA, 
                 MORSE_Complex64_t *B, int LDB);
#endif

int MORSE_zsymm(MORSE_enum side, MORSE_enum uplo, int M, int N, 
                MORSE_Complex64_t alpha, MORSE_Complex64_t *A, int LDA, 
                MORSE_Complex64_t *B, int LDB, MORSE_Complex64_t beta, 
                MORSE_Complex64_t *C, int LDC);

int MORSE_zsyrk(MORSE_enum uplo, MORSE_enum trans, int N, int K, 
                MORSE_Complex64_t alpha, MORSE_Complex64_t *A, int LDA, 
                MORSE_Complex64_t beta, MORSE_Complex64_t *C, int LDC);

int MORSE_zsyr2k(MORSE_enum uplo, MORSE_enum trans, int N, int K, 
                 MORSE_Complex64_t alpha, MORSE_Complex64_t *A, int LDA, 
                 MORSE_Complex64_t *B, int LDB, MORSE_Complex64_t beta, 
                 MORSE_Complex64_t *C, int LDC);

int MORSE_ztrmm(MORSE_enum side, MORSE_enum uplo, 
                MORSE_enum transA, MORSE_enum diag, 
                int N, int NRHS, 
                MORSE_Complex64_t alpha, MORSE_Complex64_t *A, int LDA, 
                MORSE_Complex64_t *B, int LDB);

int MORSE_ztrsm(MORSE_enum side, MORSE_enum uplo, 
                MORSE_enum transA, MORSE_enum diag, 
                int N, int NRHS, 
                MORSE_Complex64_t alpha, MORSE_Complex64_t *A, int LDA, 
                MORSE_Complex64_t *B, int LDB);

int MORSE_ztrsmpl(int N, int NRHS, MORSE_Complex64_t *A, int LDA, 
                  MORSE_desc_t *descL, int *IPIV, 
                  MORSE_Complex64_t *B, int LDB);

int MORSE_ztrsmrv(MORSE_enum side, MORSE_enum uplo, 
                  MORSE_enum transA, MORSE_enum diag, 
                  int N, int NRHS, 
                  MORSE_Complex64_t alpha, MORSE_Complex64_t *A, int LDA, 
                  MORSE_Complex64_t *B, int LDB);

int MORSE_ztrtri(MORSE_enum uplo, MORSE_enum diag, int N, 
                 MORSE_Complex64_t *A, int LDA);

int MORSE_zunglq(int M, int N, int K, MORSE_Complex64_t *A, int LDA, 
                 MORSE_desc_t *descT, MORSE_Complex64_t *B, int LDB);

int MORSE_zungqr(int M, int N, int K, MORSE_Complex64_t *A, int LDA, 
                 MORSE_desc_t *descT, MORSE_Complex64_t *B, int LDB);

int MORSE_zunmlq(MORSE_enum side, MORSE_enum trans, int M, int N, int K, 
                 MORSE_Complex64_t *A, int LDA, 
                 MORSE_desc_t *descT, 
                 MORSE_Complex64_t *B, int LDB);

int MORSE_zunmqr(MORSE_enum side, MORSE_enum trans, int M, int N, int K, 
                 MORSE_Complex64_t *A, int LDA, MORSE_desc_t *descT, 
                 MORSE_Complex64_t *B, int LDB);

/** ******************************************************
 *  Declarations of computational functions (tile layout)
 **/
 
int MORSE_zgelqf_Tile(MORSE_desc_t *A, MORSE_desc_t *T);

int MORSE_zgelqs_Tile(MORSE_desc_t *A, MORSE_desc_t *T, MORSE_desc_t *B);

int MORSE_zgels_Tile(MORSE_enum trans, MORSE_desc_t *A, MORSE_desc_t *T, 
                     MORSE_desc_t *B);
                     
int MORSE_zgemm_Tile(MORSE_enum transA, MORSE_enum transB, 
                     MORSE_Complex64_t alpha, MORSE_desc_t *A, 
                     MORSE_desc_t *B, MORSE_Complex64_t beta, 
                     MORSE_desc_t *C);
                     
int MORSE_zgeqrf_Tile(MORSE_desc_t *A, MORSE_desc_t *T);

int MORSE_zgeqrs_Tile(MORSE_desc_t *A, MORSE_desc_t *T, MORSE_desc_t *B);

int MORSE_zgesv_incpiv_Tile(MORSE_desc_t *A, MORSE_desc_t *L, int *IPIV, 
                            MORSE_desc_t *B);

int MORSE_zgesv_nopiv_Tile(MORSE_desc_t *A, MORSE_desc_t *B);

int MORSE_zgetrf_incpiv_Tile(MORSE_desc_t *A, MORSE_desc_t *L, int *IPIV);

int MORSE_zgetrf_nopiv_Tile(MORSE_desc_t *A);

int MORSE_zgetrs_incpiv_Tile(MORSE_desc_t *A, MORSE_desc_t *L, int *IPIV, 
                             MORSE_desc_t *B);
                             
int MORSE_zgetrs_nopiv_Tile(MORSE_desc_t *A, MORSE_desc_t *B);

#ifdef COMPLEX
int MORSE_zhemm_Tile(MORSE_enum side, MORSE_enum uplo, 
                     MORSE_Complex64_t alpha, MORSE_desc_t *A, 
                     MORSE_desc_t *B, MORSE_Complex64_t beta, 
                     MORSE_desc_t *C);
                     
int MORSE_zherk_Tile(MORSE_enum uplo, MORSE_enum trans, 
                     double alpha, MORSE_desc_t *A, 
                     double beta, MORSE_desc_t *C);
                     
int MORSE_zher2k_Tile(MORSE_enum uplo, MORSE_enum trans, 
                      MORSE_Complex64_t alpha, MORSE_desc_t *A, 
                      MORSE_desc_t *B, double beta, MORSE_desc_t *C);
#endif

int MORSE_zlacpy_Tile(MORSE_enum uplo, MORSE_desc_t *A, MORSE_desc_t *B);

double MORSE_zlange_Tile(MORSE_enum norm, MORSE_desc_t *A);

#ifdef COMPLEX
double MORSE_zlanhe_Tile(MORSE_enum norm, MORSE_enum uplo, MORSE_desc_t *A);
#endif

double MORSE_zlansy_Tile(MORSE_enum norm, MORSE_enum uplo, MORSE_desc_t *A);

double MORSE_zlantr_Tile(MORSE_enum norm, MORSE_enum uplo, 
                         MORSE_enum diag, MORSE_desc_t *A);

int MORSE_zlaset_Tile(MORSE_enum uplo, MORSE_Complex64_t alpha, 
                      MORSE_Complex64_t beta, MORSE_desc_t *A);
                      
int MORSE_zlauum_Tile(MORSE_enum uplo, MORSE_desc_t *A);

#ifdef COMPLEX
int MORSE_zplghe_Tile(double bump, MORSE_desc_t *A, 
                      unsigned long long int seed);
#endif

int MORSE_zplgsy_Tile(MORSE_Complex64_t bump, MORSE_desc_t *A, 
                      unsigned long long int seed );
                      
int MORSE_zplrnt_Tile(MORSE_desc_t *A, unsigned long long int seed );

int MORSE_zposv_Tile(MORSE_enum uplo, MORSE_desc_t *A, MORSE_desc_t *B);

int MORSE_zpotrf_Tile(MORSE_enum uplo, MORSE_desc_t *A);

int MORSE_zsytrf_Tile(MORSE_enum uplo, MORSE_desc_t *A);

int MORSE_zpotri_Tile(MORSE_enum uplo, MORSE_desc_t *A);

int MORSE_zpotrs_Tile(MORSE_enum uplo, MORSE_desc_t *A, MORSE_desc_t *B);

#if defined (PRECISION_c) || defined(PRECISION_z)
int MORSE_zsytrs_Tile(MORSE_enum uplo, MORSE_desc_t *A, MORSE_desc_t *B);
#endif

int MORSE_zsymm_Tile(MORSE_enum side, MORSE_enum uplo, 
                     MORSE_Complex64_t alpha, MORSE_desc_t *A, 
                     MORSE_desc_t *B, MORSE_Complex64_t beta, 
                     MORSE_desc_t *C);
                     
int MORSE_zsyrk_Tile(MORSE_enum uplo, MORSE_enum trans, 
                     MORSE_Complex64_t alpha, MORSE_desc_t *A, 
                     MORSE_Complex64_t beta, MORSE_desc_t *C);
                     
int MORSE_zsyr2k_Tile(MORSE_enum uplo, MORSE_enum trans, 
                      MORSE_Complex64_t alpha, MORSE_desc_t *A, 
                      MORSE_desc_t *B, MORSE_Complex64_t beta, 
                      MORSE_desc_t *C);
                      
int MORSE_ztrmm_Tile(MORSE_enum side, MORSE_enum uplo, 
                     MORSE_enum transA, MORSE_enum diag, 
                     MORSE_Complex64_t alpha, MORSE_desc_t *A, 
                     MORSE_desc_t *B);
                     
int MORSE_ztrsm_Tile(MORSE_enum side, MORSE_enum uplo, 
                     MORSE_enum transA, MORSE_enum diag, 
                     MORSE_Complex64_t alpha, MORSE_desc_t *A, 
                     MORSE_desc_t *B);
                     
int MORSE_ztrsmpl_Tile(MORSE_desc_t *A, MORSE_desc_t *L, 
                       int *IPIV, MORSE_desc_t *B);
                       
int MORSE_ztrsmrv_Tile(MORSE_enum side, MORSE_enum uplo, 
                       MORSE_enum transA, MORSE_enum diag, 
                       MORSE_Complex64_t alpha, MORSE_desc_t *A, 
                       MORSE_desc_t *B);
                       
int MORSE_ztrtri_Tile(MORSE_enum uplo, MORSE_enum diag, MORSE_desc_t *A);

int MORSE_zunglq_Tile(MORSE_desc_t *A, MORSE_desc_t *T, MORSE_desc_t *B);

int MORSE_zungqr_Tile(MORSE_desc_t *A, MORSE_desc_t *T, MORSE_desc_t *B);

int MORSE_zunmlq_Tile(MORSE_enum side, MORSE_enum trans, MORSE_desc_t *A, 
                      MORSE_desc_t *T, MORSE_desc_t *B);

int MORSE_zunmqr_Tile(MORSE_enum side, MORSE_enum trans, MORSE_desc_t *A, 
                      MORSE_desc_t *T, MORSE_desc_t *B);

/** ****************************************
 *  Declarations of computational functions 
 *  (tile layout, asynchronous execution)
 **/
 
int MORSE_zgelqf_Tile_Async(MORSE_desc_t *A, MORSE_desc_t *T, 
                            MORSE_sequence_t *sequence, 
                            MORSE_request_t *request);

int MORSE_zgelqs_Tile_Async(MORSE_desc_t *A, MORSE_desc_t *T, 
                            MORSE_desc_t *B, 
                            MORSE_sequence_t *sequence, 
                            MORSE_request_t *request);
                            
int MORSE_zgels_Tile_Async(MORSE_enum trans, MORSE_desc_t *A, 
                           MORSE_desc_t *T, MORSE_desc_t *B, 
                           MORSE_sequence_t *sequence, 
                           MORSE_request_t *request);

int MORSE_zgemm_Tile_Async(MORSE_enum transA, MORSE_enum transB, 
                           MORSE_Complex64_t alpha, MORSE_desc_t *A, 
                           MORSE_desc_t *B, MORSE_Complex64_t beta, 
                           MORSE_desc_t *C, MORSE_sequence_t *sequence, 
                           MORSE_request_t *request);

int MORSE_zgeqrf_Tile_Async(MORSE_desc_t *A, MORSE_desc_t *T, 
                            MORSE_sequence_t *sequence, 
                            MORSE_request_t *request)

int MORSE_zgeqrs_Tile_Async(MORSE_desc_t *A, MORSE_desc_t *T, 
                            MORSE_desc_t *B, 
			    MORSE_sequence_t *sequence, 
			    MORSE_request_t *request);

int MORSE_zgesv_incpiv_Tile_Async(MORSE_desc_t *A, MORSE_desc_t *L, 
                                  int *IPIV, MORSE_desc_t *B, 
                                  MORSE_sequence_t *sequence, 
                                  MORSE_request_t *request);

int MORSE_zgesv_nopiv_Tile_Async(MORSE_desc_t *A, MORSE_desc_t *B, 
                                 MORSE_sequence_t *sequence, 
                                 MORSE_request_t *request);

int MORSE_zgetrf_incpiv_Tile_Async(MORSE_desc_t *A, MORSE_desc_t *L, 
                                   int *IPIV, MORSE_sequence_t *sequence, 
                                   MORSE_request_t *request);

int MORSE_zgetrf_nopiv_Tile_Async(MORSE_desc_t *A, 
                                  MORSE_sequence_t *sequence, 
                                  MORSE_request_t *request);

int MORSE_zgetrs_incpiv_Tile_Async(MORSE_desc_t *A, MORSE_desc_t *L, 
                                   int *IPIV, MORSE_desc_t *B, 
                                   MORSE_sequence_t *sequence, 
                                   MORSE_request_t *request);

int MORSE_zgetrs_nopiv_Tile_Async(MORSE_desc_t *A, MORSE_desc_t *B, 
                                  MORSE_sequence_t *sequence, 
                                  MORSE_request_t *request);

#ifdef COMPLEX
int MORSE_zhemm_Tile_Async(MORSE_enum side, MORSE_enum uplo, 
                           MORSE_Complex64_t alpha, MORSE_desc_t *A, 
                           MORSE_desc_t *B, MORSE_Complex64_t beta, 
                           MORSE_desc_t *C, MORSE_sequence_t *sequence, 
                           MORSE_request_t *request);

int MORSE_zherk_Tile_Async(MORSE_enum uplo, MORSE_enum trans, 
                           double alpha, MORSE_desc_t *A, 
                           double beta, MORSE_desc_t *C, 
                           MORSE_sequence_t *sequence, 
                           MORSE_request_t *request);

int MORSE_zher2k_Tile_Async(MORSE_enum uplo, MORSE_enum trans, 
                            MORSE_Complex64_t alpha, MORSE_desc_t *A, 
                            MORSE_desc_t *B, double beta, MORSE_desc_t *C, 
                            MORSE_sequence_t *sequence, 
                            MORSE_request_t *request);
#endif

int MORSE_zlacpy_Tile_Async(MORSE_enum uplo, MORSE_desc_t *A, 
                            MORSE_desc_t *B, MORSE_sequence_t *sequence, 
                            MORSE_request_t *request);

int MORSE_zlange_Tile_Async(MORSE_enum norm, MORSE_desc_t *A, double *value, 
                            MORSE_sequence_t *sequence, 
                            MORSE_request_t *request);

#ifdef COMPLEX
int MORSE_zlanhe_Tile_Async(MORSE_enum norm, MORSE_enum uplo, 
                            MORSE_desc_t *A, double *value, 
                            MORSE_sequence_t *sequence, 
                            MORSE_request_t *request);
#endif

int MORSE_zlansy_Tile_Async(MORSE_enum norm, MORSE_enum uplo, 
                            MORSE_desc_t *A, double *value, 
                            MORSE_sequence_t *sequence, 
                            MORSE_request_t *request);

int MORSE_zlantr_Tile_Async(MORSE_enum norm, MORSE_enum uplo, 
                            MORSE_enum diag, MORSE_desc_t *A, double *value, 
                            MORSE_sequence_t *sequence, 
                            MORSE_request_t *request);

int MORSE_zlaset_Tile_Async(MORSE_enum uplo, MORSE_Complex64_t alpha, 
                            MORSE_Complex64_t beta, MORSE_desc_t *A, 
                            MORSE_sequence_t *sequence, 
                            MORSE_request_t *request);

int MORSE_zlauum_Tile_Async(MORSE_enum uplo, MORSE_desc_t *A, 
                            MORSE_sequence_t *sequence, 
                            MORSE_request_t *request);

#ifdef COMPLEX
int MORSE_zplghe_Tile_Async(double bump, MORSE_desc_t *A, 
                            unsigned long long int seed, 
                            MORSE_sequence_t *sequence, 
                            MORSE_request_t *request );
#endif

int MORSE_zplgsy_Tile_Async(MORSE_Complex64_t bump, MORSE_desc_t *A, 
                            unsigned long long int seed, 
                            MORSE_sequence_t *sequence, 
                            MORSE_request_t *request );

int MORSE_zplrnt_Tile_Async(MORSE_desc_t *A, unsigned long long int seed, 
                            MORSE_sequence_t *sequence, 
                            MORSE_request_t *request );

int MORSE_zposv_Tile_Async(MORSE_enum uplo, MORSE_desc_t *A, 
                           MORSE_desc_t *B, 
                           MORSE_sequence_t *sequence, 
                           MORSE_request_t *request);

int MORSE_zpotrf_Tile_Async(MORSE_enum uplo, MORSE_desc_t *A, 
                            MORSE_sequence_t *sequence, 
                            MORSE_request_t *request);

int MORSE_zsytrf_Tile_Async(MORSE_enum uplo, MORSE_desc_t *A, 
                            MORSE_sequence_t *sequence, 
                            MORSE_request_t *request);

int MORSE_zpotri_Tile_Async(MORSE_enum uplo, MORSE_desc_t *A, 
                            MORSE_sequence_t *sequence, 
                            MORSE_request_t *request);

int MORSE_zpotrs_Tile_Async(MORSE_enum uplo, MORSE_desc_t *A, 
                            MORSE_desc_t *B, MORSE_sequence_t *sequence, 
                            MORSE_request_t *request);

#if defined (PRECISION_c) || defined(PRECISION_z)
int MORSE_zsytrs_Tile_Async(MORSE_enum uplo, MORSE_desc_t *A, 
                            MORSE_desc_t *B, 
                            MORSE_sequence_t *sequence, 
                            MORSE_request_t *request);
#endif

int MORSE_zsymm_Tile_Async(MORSE_enum side, MORSE_enum uplo, 
                           MORSE_Complex64_t alpha, MORSE_desc_t *A, 
                           MORSE_desc_t *B, MORSE_Complex64_t beta, 
                           MORSE_desc_t *C, MORSE_sequence_t *sequence, 
                           MORSE_request_t *request);

int MORSE_zsyrk_Tile_Async(MORSE_enum uplo, MORSE_enum trans, 
                           MORSE_Complex64_t alpha, MORSE_desc_t *A, 
                           MORSE_Complex64_t beta, MORSE_desc_t *C, 
                           MORSE_sequence_t *sequence, 
                           MORSE_request_t *request);

int MORSE_zsyr2k_Tile_Async(MORSE_enum uplo, MORSE_enum trans, 
                            MORSE_Complex64_t alpha, MORSE_desc_t *A, 
                            MORSE_desc_t *B, MORSE_Complex64_t beta, 
                            MORSE_desc_t *C, MORSE_sequence_t *sequence, 
                            MORSE_request_t *request);

int MORSE_ztrmm_Tile_Async(MORSE_enum side, MORSE_enum uplo, 
                           MORSE_enum transA, MORSE_enum diag, 
                           MORSE_Complex64_t alpha, MORSE_desc_t *A, 
                           MORSE_desc_t *B, MORSE_sequence_t *sequence, 
                           MORSE_request_t *request);

int MORSE_ztrsm_Tile_Async(MORSE_enum side, MORSE_enum uplo, 
                           MORSE_enum transA, MORSE_enum diag, 
                           MORSE_Complex64_t alpha, MORSE_desc_t *A, 
                           MORSE_desc_t *B, MORSE_sequence_t *sequence, 
                           MORSE_request_t *request);

int MORSE_ztrsmpl_Tile_Async(MORSE_desc_t *A, MORSE_desc_t *L, int *IPIV, 
                             MORSE_desc_t *B, MORSE_sequence_t *sequence, 
                             MORSE_request_t *request);

int MORSE_ztrsmrv_Tile_Async(MORSE_enum side, MORSE_enum uplo, 
                             MORSE_enum transA, MORSE_enum diag, 
                             MORSE_Complex64_t alpha, MORSE_desc_t *A, 
                             MORSE_desc_t *B, MORSE_sequence_t *sequence, 
                             MORSE_request_t *request);

int MORSE_ztrtri_Tile_Async(MORSE_enum uplo, MORSE_enum diag, 
                            MORSE_desc_t *A, 
                            MORSE_sequence_t *sequence, 
                            MORSE_request_t *request);

int MORSE_zunglq_Tile_Async(MORSE_desc_t *A, MORSE_desc_t *T, 
                            MORSE_desc_t *B, 
                            MORSE_sequence_t *sequence, 
                            MORSE_request_t *request);

int MORSE_zungqr_Tile_Async(MORSE_desc_t *A, MORSE_desc_t *T, 
                            MORSE_desc_t *B, 
                            MORSE_sequence_t *sequence, 
                            MORSE_request_t *request);

int MORSE_zunmlq_Tile_Async(MORSE_enum side, MORSE_enum trans, 
                            MORSE_desc_t *A, MORSE_desc_t *T, 
                            MORSE_desc_t *B, MORSE_sequence_t *sequence, 
                            MORSE_request_t *request);

int MORSE_zunmqr_Tile_Async(MORSE_enum side, MORSE_enum trans, 
                            MORSE_desc_t *A, MORSE_desc_t *T, 
                            MORSE_desc_t *B, MORSE_sequence_t *sequence, 
                            MORSE_request_t *request);

</pre>


<hr>



</body>
</html>
